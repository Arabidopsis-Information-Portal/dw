/**
 * Copyright 2012 Carnegie Institution for Science. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDbDto.vsl

package org.tair.db.locusdetail;


import com.poesys.db.pk.IPrimaryKey;

import com.poesys.db.dto.AbstractDto;
import com.poesys.db.dto.DtoStatusException;


/**
 * <p>
 * A data-access layer data-transfer object for the LocusDetail. This class
 * is an abstract class that contains AndroMDA generated code; change nothing
 * in this class. Instead, override any methods in the concrete subclass
 * generated in the same package. AndroMDA will overwrite this class each time
 * you run it but will never overwrite the concrete subclass.
 * </p>
 * <p>
 * The central object of the subsystem, a locus, which is the location on a
 * chromosome of a gene (the concept of a physical DNA structure that maps into a
 * protein or RNA molecule and has distinct function)
 * </p>
 * <p>
 * Stereotypes:
 * </p>
 * <ul>
 *     <li>NaturalKey</li>
 *     <li>Persistent</li>
 * </ul>
 * <p>
 * Class is read/write: false
 * </p>
 *
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractLocusDetail extends AbstractDto implements ILocusDetail {
  /** Default serial version UID for the Serializable DTO */
  private static final long serialVersionUID = 1L;
  // Setter strategy nested classes for single-object associations
  
  /**
   * Nested class that manages the taxon association data
   *
   * Source: AddToOneAssociationRequiredObjectProperties
   *
   * @author Poesys/DB Cartridge
   */
  private class QueryTaxonSetter extends com.poesys.db.dto.AbstractObjectSetter<org.tair.db.basic.ITaxon> {
    private static final long serialVersionUID = 1L;
    
    /**
     * Create a QueryTaxonSetter object.
     */
    public QueryTaxonSetter() {
      super("org.tair.db.basic", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.basic.Taxon.class.getName();
    }

    @Override
    protected IPrimaryKey getKey() {
      return taxonKey;
    }

    @Override
    protected com.poesys.db.dao.query.IKeyQuerySql<org.tair.db.basic.ITaxon> getSql() {
      return new org.tair.db.basic.sql.QueryTaxon();
    }

    @Override
    protected void set(org.tair.db.basic.ITaxon dto) {
      // No status change, this is just filling in the object data.
      taxon = dto;
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated taxon is not null
      return taxon != null;
    }
  }


  /**
   * Foreign key object used by QueryTaxonSetter nested class to query object
   */
  private IPrimaryKey taxonKey;
  
  /**
   * Set the foreign key taxonKey. This has package access to enable
   * the subsystem factory getData method to call this method to set the key
   * by creating it from the queried result set.
   *
   * @param taxonKey the foreign key
   */
  void setTaxonKey(IPrimaryKey taxonKey) {
    this.taxonKey = taxonKey;
  }

  // Setter strategy nested classes for multiple-object associations

   
  /**
   * Query setter for querying nested locusAnnotation
   *
   * Source: AddAssociationClassCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryLocusAnnotationByLocusDetail
   */
  private class QueryLocusAnnotationSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusAnnotation, ILocusDetail, java.util.Collection<org.tair.db.locusdetail.ILocusAnnotation>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryLocusAnnotationSetter object.
     */
    public QueryLocusAnnotationSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusAnnotation.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusAnnotation, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryLocusAnnotationByLocusDetail();
    }

    @Override
    protected void set(java.util.Collection<org.tair.db.locusdetail.ILocusAnnotation> list) {
      // No status change; this is just filling in the object data.
      locusAnnotation = list;
      // Add the primary keys to the serialized key list if there are any.
      if (locusAnnotation != null) {
        for (com.poesys.db.dto.IDbDto object : locusAnnotation) {
          locusAnnotationKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated locusAnnotation list is not null
      return locusAnnotation != null;
    }
  }
   
  /**
   * Query setter for querying nested updateHistories
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryUpdateHistoriesByLocusDetail
   */
  private class QueryUpdateHistoriesSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusUpdateHistory, ILocusDetail, java.util.List<org.tair.db.locusdetail.ILocusUpdateHistory>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryUpdateHistoriesSetter object.
     */
    public QueryUpdateHistoriesSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusUpdateHistory.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusUpdateHistory, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryUpdateHistoriesByLocusDetail();
    }

    @Override
    protected void set(java.util.List<org.tair.db.locusdetail.ILocusUpdateHistory> list) {
      // No status change; this is just filling in the object data.
      updateHistories = list;
      // Add the primary keys to the serialized key list if there are any.
      if (updateHistories != null) {
        for (com.poesys.db.dto.IDbDto object : updateHistories) {
          updateHistoriesKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated updateHistories list is not null
      return updateHistories != null;
    }
  }
   
  /**
   * Query setter for querying nested geneModels
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryGeneModelsByLocusDetail
   */
  private class QueryGeneModelsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusGeneModel, ILocusDetail, java.util.Collection<org.tair.db.locusdetail.ILocusGeneModel>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryGeneModelsSetter object.
     */
    public QueryGeneModelsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusGeneModel.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusGeneModel, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryGeneModelsByLocusDetail();
    }

    @Override
    protected void set(java.util.Collection<org.tair.db.locusdetail.ILocusGeneModel> list) {
      // No status change; this is just filling in the object data.
      geneModels = list;
      // Add the primary keys to the serialized key list if there are any.
      if (geneModels != null) {
        for (com.poesys.db.dto.IDbDto object : geneModels) {
          geneModelsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated geneModels list is not null
      return geneModels != null;
    }
  }
   
  /**
   * Query setter for querying nested otherNames
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryOtherNamesByLocusDetail
   */
  private class QueryOtherNamesSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusOtherName, ILocusDetail, java.util.List<org.tair.db.locusdetail.ILocusOtherName>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryOtherNamesSetter object.
     */
    public QueryOtherNamesSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusOtherName.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusOtherName, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryOtherNamesByLocusDetail();
    }

    @Override
    protected void set(java.util.List<org.tair.db.locusdetail.ILocusOtherName> list) {
      // No status change; this is just filling in the object data.
      otherNames = list;
      // Add the primary keys to the serialized key list if there are any.
      if (otherNames != null) {
        for (com.poesys.db.dto.IDbDto object : otherNames) {
          otherNamesKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated otherNames list is not null
      return otherNames != null;
    }
  }
   
  /**
   * Query setter for querying nested locations
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryLocationsByLocusDetail
   */
  private class QueryLocationsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusPhysicalMapCoordinates, ILocusDetail, java.util.Collection<org.tair.db.locusdetail.ILocusPhysicalMapCoordinates>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryLocationsSetter object.
     */
    public QueryLocationsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusPhysicalMapCoordinates.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusPhysicalMapCoordinates, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryLocationsByLocusDetail();
    }

    @Override
    protected void set(java.util.Collection<org.tair.db.locusdetail.ILocusPhysicalMapCoordinates> list) {
      // No status change; this is just filling in the object data.
      locations = list;
      // Add the primary keys to the serialized key list if there are any.
      if (locations != null) {
        for (com.poesys.db.dto.IDbDto object : locations) {
          locationsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated locations list is not null
      return locations != null;
    }
  }
   
  /**
   * Query setter for querying nested resourceLinks
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryResourceLinksByLocusDetail
   */
  private class QueryResourceLinksSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusResourceLink, ILocusDetail, java.util.List<org.tair.db.locusdetail.ILocusResourceLink>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryResourceLinksSetter object.
     */
    public QueryResourceLinksSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusResourceLink.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusResourceLink, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryResourceLinksByLocusDetail();
    }

    @Override
    protected void set(java.util.List<org.tair.db.locusdetail.ILocusResourceLink> list) {
      // No status change; this is just filling in the object data.
      resourceLinks = list;
      // Add the primary keys to the serialized key list if there are any.
      if (resourceLinks != null) {
        for (com.poesys.db.dto.IDbDto object : resourceLinks) {
          resourceLinksKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated resourceLinks list is not null
      return resourceLinks != null;
    }
  }
   
  /**
   * Query setter for querying nested comments
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryCommentsByLocusDetail
   */
  private class QueryCommentsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusComment, ILocusDetail, java.util.List<org.tair.db.locusdetail.ILocusComment>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryCommentsSetter object.
     */
    public QueryCommentsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusComment.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusComment, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryCommentsByLocusDetail();
    }

    @Override
    protected void set(java.util.List<org.tair.db.locusdetail.ILocusComment> list) {
      // No status change; this is just filling in the object data.
      comments = list;
      // Add the primary keys to the serialized key list if there are any.
      if (comments != null) {
        for (com.poesys.db.dto.IDbDto object : comments) {
          commentsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated comments list is not null
      return comments != null;
    }
  }
   
  /**
   * Query setter for querying nested attributions
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryAttributionsByLocusDetail
   */
  private class QueryAttributionsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusAttribution, ILocusDetail, java.util.List<org.tair.db.locusdetail.ILocusAttribution>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryAttributionsSetter object.
     */
    public QueryAttributionsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusAttribution.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusAttribution, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryAttributionsByLocusDetail();
    }

    @Override
    protected void set(java.util.List<org.tair.db.locusdetail.ILocusAttribution> list) {
      // No status change; this is just filling in the object data.
      attributions = list;
      // Add the primary keys to the serialized key list if there are any.
      if (attributions != null) {
        for (com.poesys.db.dto.IDbDto object : attributions) {
          attributionsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated attributions list is not null
      return attributions != null;
    }
  }
   
  /**
   * Query setter for querying nested otherSymbols
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryOtherSymbolsByLocusDetail
   */
  private class QueryOtherSymbolsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusOtherSymbol, ILocusDetail, java.util.List<org.tair.db.locusdetail.ILocusOtherSymbol>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryOtherSymbolsSetter object.
     */
    public QueryOtherSymbolsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusOtherSymbol.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusOtherSymbol, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryOtherSymbolsByLocusDetail();
    }

    @Override
    protected void set(java.util.List<org.tair.db.locusdetail.ILocusOtherSymbol> list) {
      // No status change; this is just filling in the object data.
      otherSymbols = list;
      // Add the primary keys to the serialized key list if there are any.
      if (otherSymbols != null) {
        for (com.poesys.db.dto.IDbDto object : otherSymbols) {
          otherSymbolsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated otherSymbols list is not null
      return otherSymbols != null;
    }
  }
   
  /**
   * Query setter for querying nested polymorphisms
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryPolymorphismsByLocusDetail
   */
  private class QueryPolymorphismsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusPolymorphism, ILocusDetail, java.util.Collection<org.tair.db.locusdetail.ILocusPolymorphism>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryPolymorphismsSetter object.
     */
    public QueryPolymorphismsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusPolymorphism.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusPolymorphism, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryPolymorphismsByLocusDetail();
    }

    @Override
    protected void set(java.util.Collection<org.tair.db.locusdetail.ILocusPolymorphism> list) {
      // No status change; this is just filling in the object data.
      polymorphisms = list;
      // Add the primary keys to the serialized key list if there are any.
      if (polymorphisms != null) {
        for (com.poesys.db.dto.IDbDto object : polymorphisms) {
          polymorphismsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated polymorphisms list is not null
      return polymorphisms != null;
    }
  }
   
   
  /**
   * Query setter for querying nested bacs
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryBacsByLocusDetail
   */
  private class QueryBacsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusBac, ILocusDetail, java.util.Collection<org.tair.db.locusdetail.ILocusBac>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryBacsSetter object.
     */
    public QueryBacsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusBac.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusBac, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryBacsByLocusDetail();
    }

    @Override
    protected void set(java.util.Collection<org.tair.db.locusdetail.ILocusBac> list) {
      // No status change; this is just filling in the object data.
      bacs = list;
      // Add the primary keys to the serialized key list if there are any.
      if (bacs != null) {
        for (com.poesys.db.dto.IDbDto object : bacs) {
          bacsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated bacs list is not null
      return bacs != null;
    }
  }
   
  /**
   * Query setter for querying nested ests
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryEstsByLocusDetail
   */
  private class QueryEstsSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocuslEst, ILocusDetail, java.util.Collection<org.tair.db.locusdetail.ILocuslEst>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryEstsSetter object.
     */
    public QueryEstsSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocuslEst.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocuslEst, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryEstsByLocusDetail();
    }

    @Override
    protected void set(java.util.Collection<org.tair.db.locusdetail.ILocuslEst> list) {
      // No status change; this is just filling in the object data.
      ests = list;
      // Add the primary keys to the serialized key list if there are any.
      if (ests != null) {
        for (com.poesys.db.dto.IDbDto object : ests) {
          estsKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated ests list is not null
      return ests != null;
    }
  }
   
  /**
   * Query setter for querying nested cDnas
   *
   * Source: AddToManyChildCollectionProperties
   *
   * @see org.tair.db.locusdetail.sql.QueryCDnasByLocusDetail
   */
  private class QueryCDnasSetter 
      extends com.poesys.db.dto.AbstractListSetter<org.tair.db.locusdetail.ILocusCdna, ILocusDetail, java.util.Collection<org.tair.db.locusdetail.ILocusCdna>> {
    private static final long serialVersionUID = 1L;
    private static final int FETCH_SIZE = 10;

    /**
     * Create a QueryCDnasSetter object.
     */
    public QueryCDnasSetter() {
      super("org.tair.db.locusdetail", 2147483647);
    }

    @Override
    protected String getClassName() {
      return org.tair.db.locusdetail.LocusCdna.class.getName();
    }

    @Override
    protected int getFetchSize() {
      return FETCH_SIZE;
    }

    @Override
    protected ILocusDetail getParametersDto() {
      return AbstractLocusDetail.this;
    }

    @Override
    protected com.poesys.db.dao.query.IParameterizedQuerySql<org.tair.db.locusdetail.ILocusCdna, ILocusDetail> getSql() {
      return new org.tair.db.locusdetail.sql.QueryCDnasByLocusDetail();
    }

    @Override
    protected void set(java.util.Collection<org.tair.db.locusdetail.ILocusCdna> list) {
      // No status change; this is just filling in the object data.
      cDnas = list;
      // Add the primary keys to the serialized key list if there are any.
      if (cDnas != null) {
        for (com.poesys.db.dto.IDbDto object : cDnas) {
          cDnasKeys.add(object.getPrimaryKey());
        }
      }
    }

    @Override
    public boolean isSet() {
      // Object is set if the associated cDnas list is not null
      return cDnas != null;
    }
  }
   
  /**
   * Create an empty LocusDetail for use in building a new object. The 
   * concrete subclass must call this constructor.
   */
  public AbstractLocusDetail() {
    // Setter arrays
    querySetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    insertSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    preSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    postSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    readObjectSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();

    // Add the setters for the taxon property.
    querySetters.add(new QueryTaxonSetter());
    
    // Add the many-to-many collection setters for the annotation property.
    
    // Add the many-to-many collection setters for the locusAnnotation property.
    querySetters.add(new QueryLocusAnnotationSetter());
    
    // Add the many-to-many collection setters for the updateHistories property.
    querySetters.add(new QueryUpdateHistoriesSetter());
    
    // Add the many-to-many collection setters for the geneModels property.
    querySetters.add(new QueryGeneModelsSetter());
    
    // Add the many-to-many collection setters for the otherNames property.
    querySetters.add(new QueryOtherNamesSetter());
    
    // Add the many-to-many collection setters for the locations property.
    querySetters.add(new QueryLocationsSetter());
    
    // Add the many-to-many collection setters for the resourceLinks property.
    querySetters.add(new QueryResourceLinksSetter());
    
    // Add the many-to-many collection setters for the comments property.
    querySetters.add(new QueryCommentsSetter());
    
    // Add the many-to-many collection setters for the attributions property.
    querySetters.add(new QueryAttributionsSetter());
    
    // Add the many-to-many collection setters for the otherSymbols property.
    querySetters.add(new QueryOtherSymbolsSetter());
    
    // Add the many-to-many collection setters for the polymorphisms property.
    querySetters.add(new QueryPolymorphismsSetter());
    
    // Add the many-to-many collection setters for the references property.
    
    // Add the many-to-many collection setters for the bacs property.
    querySetters.add(new QueryBacsSetter());
    
    // Add the many-to-many collection setters for the ests property.
    querySetters.add(new QueryEstsSetter());
    
    // Add the many-to-many collection setters for the cDnas property.
    querySetters.add(new QueryCDnasSetter());
  }

  /**
   * Create a LocusDetail. The concrete subclass must call this constructor.
   *
   * @param key the primary key of the LocusDetail
   * @param locusTairObjectId unique identifier for the locus as a TAIR object
   * @param locusName the locus name (usually an AGI name in the form ATcGnnnnn, where the c is the
chromosome (1-5, C, M)
   * @param primarySymbol the primary symbolic name for the locus
   * @param primarySymbolFullName the full name for the primary symbolic name for the locus (may be null)
   * @param chromosome the chromosome on which the locus is positioned (1-5, M, C)
   * @param spanStartPosition the starting base pair number of the locus on the chromosome; used in displaying
the gene structure graphic
   * @param spanEndPosition the end base pair number of the locus on the chromosome; used in displaying the
gene structure graphic
   * @param curatedSummary an optional, general summary of the locus written by a curator; not a gene model
summary
   * @param geneModelCount the number of gene models associated to this locus
   * @param polymorphismCount the number of polymorphisms associated with this locus
   * @param articleCount the number of journal articles associated with this locus
   * @param abstractCount the number of conference proceedings abstracts that refer to this locus
   * @param geneFamilyName the optional name of the gene family that contains this locus
   * @param geneFamilyTairObjectId the optional TAIR object id of the gene family that contains this locus; used to
link to the gene family page
   * @param taxonId foreign key used by setter to query associated object
   */
  public AbstractLocusDetail(IPrimaryKey key, java.lang.Long locusTairObjectId, java.lang.String locusName, java.lang.String primarySymbol, java.lang.String primarySymbolFullName, java.lang.String chromosome, java.lang.Long spanStartPosition, java.lang.Long spanEndPosition, java.lang.String curatedSummary, java.lang.Long geneModelCount, java.lang.Long polymorphismCount, java.lang.Long articleCount, java.lang.Long abstractCount, java.lang.String geneFamilyName, java.lang.Long geneFamilyTairObjectId, java.lang.Long taxonId) {
    this.key = key;

    this.locusTairObjectId = locusTairObjectId;

    if (locusTairObjectId == null) {
      throw new com.poesys.db.InvalidParametersException("locusTairObjectId is required for " + key.getValueList());
    }
    
    this.locusName = locusName;

    if (locusName == null) {
      throw new com.poesys.db.InvalidParametersException("locusName is required for " + key.getValueList());
    }
    
    this.primarySymbol = primarySymbol;

    if (primarySymbol == null) {
      throw new com.poesys.db.InvalidParametersException("primarySymbol is required for " + key.getValueList());
    }
    
    this.primarySymbolFullName = primarySymbolFullName;

    this.chromosome = chromosome;

    if (chromosome == null) {
      throw new com.poesys.db.InvalidParametersException("chromosome is required for " + key.getValueList());
    }
    
    this.spanStartPosition = spanStartPosition;

    if (spanStartPosition == null) {
      throw new com.poesys.db.InvalidParametersException("spanStartPosition is required for " + key.getValueList());
    }
    
    this.spanEndPosition = spanEndPosition;

    if (spanEndPosition == null) {
      throw new com.poesys.db.InvalidParametersException("spanEndPosition is required for " + key.getValueList());
    }
    
    this.curatedSummary = curatedSummary;

    this.geneModelCount = geneModelCount;

    if (geneModelCount == null) {
      throw new com.poesys.db.InvalidParametersException("geneModelCount is required for " + key.getValueList());
    }
    
    this.polymorphismCount = polymorphismCount;

    if (polymorphismCount == null) {
      throw new com.poesys.db.InvalidParametersException("polymorphismCount is required for " + key.getValueList());
    }
    
    this.articleCount = articleCount;

    if (articleCount == null) {
      throw new com.poesys.db.InvalidParametersException("articleCount is required for " + key.getValueList());
    }
    
    this.abstractCount = abstractCount;

    if (abstractCount == null) {
      throw new com.poesys.db.InvalidParametersException("abstractCount is required for " + key.getValueList());
    }
    
    this.geneFamilyName = geneFamilyName;

    this.geneFamilyTairObjectId = geneFamilyTairObjectId;

    this.taxonId = taxonId;

    if (taxonId == null) {
      throw new com.poesys.db.InvalidParametersException("taxonId is required for " + key.getValueList());
    }
    
    // Setter arrays
    querySetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    insertQuerySetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    insertSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    preSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    postSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    readObjectSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    
    // Add the setters for the taxon property.
    querySetters.add(new QueryTaxonSetter());
    
    // Set the internal key data member for the taxon object retrieval.
    taxonKey = org.tair.db.basic.BasicFactory.getTaxonPrimaryKey(taxonId/* Source: AddNaturalKeyProperties + addAssociationForeignKeys: taxonId Key: false */);
    // Add a setter to instantiate the required taxon object before insert.
    insertQuerySetters.add(new QueryTaxonSetter());
    
    // Add the many-to-many collection setters for the annotation property.
    
    // Add the many-to-many collection setters for the locusAnnotation property.
    querySetters.add(new QueryLocusAnnotationSetter());
    
    // Add the many-to-many collection setters for the updateHistories property.
    querySetters.add(new QueryUpdateHistoriesSetter());
    
    // Add the many-to-many collection setters for the geneModels property.
    querySetters.add(new QueryGeneModelsSetter());
    
    // Add the many-to-many collection setters for the otherNames property.
    querySetters.add(new QueryOtherNamesSetter());
    
    // Add the many-to-many collection setters for the locations property.
    querySetters.add(new QueryLocationsSetter());
    
    // Add the many-to-many collection setters for the resourceLinks property.
    querySetters.add(new QueryResourceLinksSetter());
    
    // Add the many-to-many collection setters for the comments property.
    querySetters.add(new QueryCommentsSetter());
    
    // Add the many-to-many collection setters for the attributions property.
    querySetters.add(new QueryAttributionsSetter());
    
    // Add the many-to-many collection setters for the otherSymbols property.
    querySetters.add(new QueryOtherSymbolsSetter());
    
    // Add the many-to-many collection setters for the polymorphisms property.
    querySetters.add(new QueryPolymorphismsSetter());
    
    // Add the many-to-many collection setters for the references property.
    
    // Add the many-to-many collection setters for the bacs property.
    querySetters.add(new QueryBacsSetter());
    
    // Add the many-to-many collection setters for the ests property.
    querySetters.add(new QueryEstsSetter());
    
    // Add the many-to-many collection setters for the cDnas property.
    querySetters.add(new QueryCDnasSetter());
  }

  @Override
  public boolean equals(Object arg0) {
    AbstractLocusDetail other = (AbstractLocusDetail)arg0;
    return other.key.equals(key);
  }

  @Override
  public int hashCode() {
    return key.hashCode();
  }

  @Override
  public int compareTo(com.poesys.db.dto.IDbDto o) {
    AbstractLocusDetail other = (AbstractLocusDetail)o;
    // Sort on the key. Same semantics as equals and hashCode().
    return other.key.compareTo(key);
  }
  
  @Override
  public String getSubsystem() {
    return "org.tair.db.locusdetail";
  }

  @Override
  public void markChildrenDeleted() throws DtoStatusException {
    // Only process deletes if child exists.
    if (updateHistories != null) {
      for (com.poesys.db.dto.IDbDto dto : updateHistories) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (geneModels != null) {
      for (com.poesys.db.dto.IDbDto dto : geneModels) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (otherNames != null) {
      for (com.poesys.db.dto.IDbDto dto : otherNames) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (locations != null) {
      for (com.poesys.db.dto.IDbDto dto : locations) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (resourceLinks != null) {
      for (com.poesys.db.dto.IDbDto dto : resourceLinks) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (comments != null) {
      for (com.poesys.db.dto.IDbDto dto : comments) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (attributions != null) {
      for (com.poesys.db.dto.IDbDto dto : attributions) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (otherSymbols != null) {
      for (com.poesys.db.dto.IDbDto dto : otherSymbols) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (polymorphisms != null) {
      for (com.poesys.db.dto.IDbDto dto : polymorphisms) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (references != null) {
      for (com.poesys.db.dto.IDbDto dto : references) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (bacs != null) {
      for (com.poesys.db.dto.IDbDto dto : bacs) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (ests != null) {
      for (com.poesys.db.dto.IDbDto dto : ests) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (cDnas != null) {
      for (com.poesys.db.dto.IDbDto dto : cDnas) {
        dto.cascadeDelete();
      }
    }
    // Only process deletes if child exists.
    if (locusAnnotation != null) {
      for (com.poesys.db.dto.IDbDto dto : locusAnnotation) {
        dto.cascadeDelete();
      }
    }
  }

  @Override
  public IPrimaryKey getPrimaryKey() {
    return key;
  }
  
  @Override
  public java.sql.Connection getConnection() throws java.sql.SQLException {
    java.sql.Connection connection = null;
    
	/* 
	 * The resource bundle for the DTO's subsystem contains the suffix that
	 * distinguishes multiple versions of the subsystem in the database.properties
	 * file, such as "prod" or "test". Most database.properties files have only
	 * one implementation and use external facilities to switch between the
	 * databases (JNDI, for example, or producing different database.properties
	 * files in different setups). Use the subsystem resource bundle to get the
	 * suffix, then use the full subsystem name to get a connection factory for
	 * the DTO's subsystem, then use that factory to get a JDBC connection.
	 */
	java.util.ResourceBundle rb = 
	  java.util.ResourceBundle.getBundle("org.tair.db.locusdetail");
    String subsystem =
      "org.tair.db.locusdetail"
          + (rb.getString("suffix") == null
             || rb.getString("suffix").length() == 0 ? ""
              : "." + rb.getString("suffix"));
	  
	try {
	  connection = 
	    com.poesys.db.connection.ConnectionFactoryFactory.getInstance(subsystem).getConnection();
	} catch (com.poesys.db.InvalidParametersException e) {
	  throw new java.sql.SQLException(e.getMessage());
	} catch (java.io.IOException e) {
	  throw new java.sql.SQLException(e.getMessage());
	}
	
	return connection;
  }

  /**
   * Nested property locusTairObjectId
   *
   * <p>
   * unique identifier for the locus as a TAIR object
   * </p>
   *
   * Added by AddNaturalKeyProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long locusTairObjectId;
  

  public java.lang.Long getLocusTairObjectId() {
    return locusTairObjectId;
  }

  /**
   * Clear the locusTairObjectId data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearLocusTairObjectId() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property locusName
   *
   * <p>
   * the locus name (usually an AGI name in the form ATcGnnnnn, where the c is the
   * chromosome (1-5, C, M)
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String locusName;
  

  public java.lang.String getLocusName() {
    return locusName;
  }

  /**
   * Clear the locusName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearLocusName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property primarySymbol
   *
   * <p>
   * the primary symbolic name for the locus
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String primarySymbol;
  

  public java.lang.String getPrimarySymbol() {
    return primarySymbol;
  }

  /**
   * Clear the primarySymbol data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearPrimarySymbol() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property primarySymbolFullName
   *
   * <p>
   * the full name for the primary symbolic name for the locus (may be null)
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String primarySymbolFullName;
  

  public java.lang.String getPrimarySymbolFullName() {
    return primarySymbolFullName;
  }

  /**
   * Clear the primarySymbolFullName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearPrimarySymbolFullName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property chromosome
   *
   * <p>
   * the chromosome on which the locus is positioned (1-5, M, C)
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String chromosome;
  

  public java.lang.String getChromosome() {
    return chromosome;
  }

  /**
   * Clear the chromosome data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearChromosome() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property spanStartPosition
   *
   * <p>
   * the starting base pair number of the locus on the chromosome; used in displaying
   * the gene structure graphic
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long spanStartPosition;
  

  public java.lang.Long getSpanStartPosition() {
    return spanStartPosition;
  }

  /**
   * Clear the spanStartPosition data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearSpanStartPosition() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property spanEndPosition
   *
   * <p>
   * the end base pair number of the locus on the chromosome; used in displaying the
   * gene structure graphic
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long spanEndPosition;
  

  public java.lang.Long getSpanEndPosition() {
    return spanEndPosition;
  }

  /**
   * Clear the spanEndPosition data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearSpanEndPosition() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property curatedSummary
   *
   * <p>
   * an optional, general summary of the locus written by a curator; not a gene model
   * summary
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String curatedSummary;
  

  public java.lang.String getCuratedSummary() {
    return curatedSummary;
  }

  /**
   * Clear the curatedSummary data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearCuratedSummary() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property geneModelCount
   *
   * <p>
   * the number of gene models associated to this locus
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long geneModelCount;
  

  public java.lang.Long getGeneModelCount() {
    return geneModelCount;
  }

  /**
   * Clear the geneModelCount data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearGeneModelCount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property polymorphismCount
   *
   * <p>
   * the number of polymorphisms associated with this locus
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long polymorphismCount;
  

  public java.lang.Long getPolymorphismCount() {
    return polymorphismCount;
  }

  /**
   * Clear the polymorphismCount data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearPolymorphismCount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property articleCount
   *
   * <p>
   * the number of journal articles associated with this locus
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long articleCount;
  

  public java.lang.Long getArticleCount() {
    return articleCount;
  }

  /**
   * Clear the articleCount data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearArticleCount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property abstractCount
   *
   * <p>
   * the number of conference proceedings abstracts that refer to this locus
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long abstractCount;
  

  public java.lang.Long getAbstractCount() {
    return abstractCount;
  }

  /**
   * Clear the abstractCount data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearAbstractCount() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property geneFamilyName
   *
   * <p>
   * the optional name of the gene family that contains this locus
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String geneFamilyName;
  

  public java.lang.String getGeneFamilyName() {
    return geneFamilyName;
  }

  /**
   * Clear the geneFamilyName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearGeneFamilyName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property geneFamilyTairObjectId
   *
   * <p>
   * the optional TAIR object id of the gene family that contains this locus; used to
   * link to the gene family page
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long geneFamilyTairObjectId;
  

  public java.lang.Long getGeneFamilyTairObjectId() {
    return geneFamilyTairObjectId;
  }

  /**
   * Clear the geneFamilyTairObjectId data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearGeneFamilyTairObjectId() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property taxon
   *
   * <p>
   * the taxon (species name) for the species of the locus
   * </p>
   *
   * Added by AddToOneAssociationRequiredObjectProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private org.tair.db.basic.ITaxon taxon;
  

  public org.tair.db.basic.ITaxon getTaxon() {
    return taxon;
  }

  /**
   * Clear the taxon data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearTaxon() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property taxonId
   *
   * <p>
   * Foreign key used by setter to query associated object
   * </p>
   *
   * Added by AddNaturalKeyProperties + AddToOneAssociationAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.Long taxonId;
  

  public java.lang.Long getTaxonId() {
    return taxonId;
  }

  /**
   * Clear the taxonId data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearTaxonId() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property annotation
   *
   * <p>
   * the set of annotations associated with the locus
   * </p>
   *
   * Added by TransformToProperty + AddToManyAssociationCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.IAnnotation> annotation;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> annotationKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.IAnnotation> getAnnotation() throws java.sql.SQLException {
    return annotation;
  }

  /**
   * Clear the annotation data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearAnnotation() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  public void setAnnotation(java.util.Collection<org.tair.db.locusdetail.IAnnotation> annotation) {
    this.annotation = annotation;
    // Add the primary keys of the new collection to the serialized key list.
    annotationKeys.clear();
    if (annotation != null) {
      for (com.poesys.db.dto.IDbDto object : annotation) {
        annotationKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property locusAnnotation
   *
   * <p>
   * Collection of association class objects (not the associated objects)
   * </p>
   *
   * Added by AddAssociationClassCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: true
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.ILocusAnnotation> locusAnnotation;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> locusAnnotationKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.ILocusAnnotation> getLocusAnnotation() {
    return locusAnnotation;
  }

  /**
   * Clear the locusAnnotation data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearLocusAnnotation() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property updateHistories
   *
   * <p>
   * an ordered list of updates to the locus, in the order in which the updates
   * occurred
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.List<org.tair.db.locusdetail.ILocusUpdateHistory> updateHistories;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> updateHistoriesKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.List<org.tair.db.locusdetail.ILocusUpdateHistory> getUpdateHistories() {
    return updateHistories;
  }

  /**
   * Clear the updateHistories data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearUpdateHistories() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property geneModels
   *
   * <p>
   * the set of gene models for the locus
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.ILocusGeneModel> geneModels;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> geneModelsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.ILocusGeneModel> getGeneModels() {
    return geneModels;
  }

  /**
   * Clear the geneModels data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearGeneModels() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property otherNames
   *
   * <p>
   * a list in alphabetical order of the "other" names for the locus, including gene
   * model names, gene aliases, symbols, and full names other than the representative
   * gene model name or the splice-variant names
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.List<org.tair.db.locusdetail.ILocusOtherName> otherNames;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> otherNamesKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.List<org.tair.db.locusdetail.ILocusOtherName> getOtherNames() {
    return otherNames;
  }

  /**
   * Clear the otherNames data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearOtherNames() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property locations
   *
   * <p>
   * the set of locations for the locus on various maps
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.ILocusPhysicalMapCoordinates> locations;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> locationsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.ILocusPhysicalMapCoordinates> getLocations() {
    return locations;
  }

  /**
   * Clear the locations data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearLocations() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property resourceLinks
   *
   * <p>
   * the alphabetically ordered list of links (URLs) to third-party resources
   * relevant to the locus
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.List<org.tair.db.locusdetail.ILocusResourceLink> resourceLinks;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> resourceLinksKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.List<org.tair.db.locusdetail.ILocusResourceLink> getResourceLinks() {
    return resourceLinks;
  }

  /**
   * Clear the resourceLinks data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearResourceLinks() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property comments
   *
   * <p>
   * the ordered list of comments associated with a locus; the list is ordered by the
   * date entered in descending order
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.List<org.tair.db.locusdetail.ILocusComment> comments;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> commentsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.List<org.tair.db.locusdetail.ILocusComment> getComments() {
    return comments;
  }

  /**
   * Clear the comments data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearComments() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property attributions
   *
   * <p>
   * the ordered list of community members to whom the presence of the locus in the
   * database is due
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.List<org.tair.db.locusdetail.ILocusAttribution> attributions;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> attributionsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.List<org.tair.db.locusdetail.ILocusAttribution> getAttributions() {
    return attributions;
  }

  /**
   * Clear the attributions data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearAttributions() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property otherSymbols
   *
   * 
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.List<org.tair.db.locusdetail.ILocusOtherSymbol> otherSymbols;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> otherSymbolsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.List<org.tair.db.locusdetail.ILocusOtherSymbol> getOtherSymbols() {
    return otherSymbols;
  }

  /**
   * Clear the otherSymbols data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearOtherSymbols() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property polymorphisms
   *
   * <p>
   * the polymorphisms that occur within the locus
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.ILocusPolymorphism> polymorphisms;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> polymorphismsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.ILocusPolymorphism> getPolymorphisms() {
    return polymorphisms;
  }

  /**
   * Clear the polymorphisms data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearPolymorphisms() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property references
   *
   * <p>
   * the set of references that refer to this locus; limited to a certain number of
   * references ordered by publication year (descending) and number of loci mentioned
   * (descending) to identify the references most likely to be of use
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.List<org.tair.db.locusdetail.IReference> references;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> referencesKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.List<org.tair.db.locusdetail.IReference> getReferences() throws java.sql.SQLException {
    return references;
  }

  /**
   * Clear the references data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearReferences() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  public void setReferences(java.util.List<org.tair.db.locusdetail.IReference> references) {
    this.references = references;
    // Add the primary keys of the new collection to the serialized key list.
    referencesKeys.clear();
    if (references != null) {
      for (com.poesys.db.dto.IDbDto object : references) {
        referencesKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property bacs
   *
   * <p>
   * the set of BACs that contain the parent locus
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.ILocusBac> bacs;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> bacsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.ILocusBac> getBacs() {
    return bacs;
  }

  /**
   * Clear the bacs data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearBacs() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property ests
   *
   * <p>
   * the EST clone ends that tag the locus
   * </p>
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.ILocuslEst> ests;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> estsKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.ILocuslEst> getEsts() {
    return ests;
  }

  /**
   * Clear the ests data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearEsts() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property cDnas
   *
   * 
   *
   * Added by AddToManyChildCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.locusdetail.ILocusCdna> cDnas;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> cDnasKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.locusdetail.ILocusCdna> getCDnas() {
    return cDnas;
  }

  /**
   * Clear the cDnas data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearCDnas() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  @Override
  public void update(com.poesys.db.dto.ISubject subject,
                     com.poesys.db.dao.DataEvent event)
      throws com.poesys.db.dto.DtoStatusException {

    // Clean up updateHistories.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusUpdateHistory && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        updateHistories != null) {
      // Delete to-many updateHistories child from collection
      updateHistories.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up geneModels.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusGeneModel && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        geneModels != null) {
      // Delete to-many geneModels child from collection
      geneModels.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up otherNames.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusOtherName && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        otherNames != null) {
      // Delete to-many otherNames child from collection
      otherNames.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up locations.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusPhysicalMapCoordinates && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        locations != null) {
      // Delete to-many locations child from collection
      locations.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up resourceLinks.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusResourceLink && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        resourceLinks != null) {
      // Delete to-many resourceLinks child from collection
      resourceLinks.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up comments.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusComment && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        comments != null) {
      // Delete to-many comments child from collection
      comments.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up attributions.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusAttribution && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        attributions != null) {
      // Delete to-many attributions child from collection
      attributions.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up otherSymbols.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusOtherSymbol && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        otherSymbols != null) {
      // Delete to-many otherSymbols child from collection
      otherSymbols.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up polymorphisms.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusPolymorphism && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        polymorphisms != null) {
      // Delete to-many polymorphisms child from collection
      polymorphisms.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up references.
    if (subject != null && subject instanceof org.tair.db.locusdetail.IReference && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        references != null) {
      // Delete to-many references child from collection
      references.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up bacs.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusBac && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        bacs != null) {
      // Delete to-many bacs child from collection
      bacs.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up ests.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocuslEst && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        ests != null) {
      // Delete to-many ests child from collection
      ests.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up cDnas.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusCdna && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        cDnas != null) {
      // Delete to-many cDnas child from collection
      cDnas.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Clean up locusAnnotation.
    if (subject != null && subject instanceof org.tair.db.locusdetail.ILocusAnnotation && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        locusAnnotation != null) {
      // Delete to-many locusAnnotation child from collection
      locusAnnotation.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Cascade delete to locusAnnotation.
    if (event == com.poesys.db.dao.DataEvent.MARKED_DELETED &&
        locusAnnotation != null) {
      // Mark locusAnnotation association object cascade-deleted.
      outer: for (org.tair.db.locusdetail.ILocusAnnotation value : locusAnnotation) {
        com.poesys.db.pk.AssociationPrimaryKey keys = 
          (com.poesys.db.pk.AssociationPrimaryKey) value.getPrimaryKey();
        for (com.poesys.db.pk.IPrimaryKey key : keys.getKeyListCopy()) {
          if (key.equals(subject.getPrimaryKey())) {
            value.cascadeDelete();
            break outer;
          }
        }
      }
    }
  }
}