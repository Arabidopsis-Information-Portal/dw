/**
 * Copyright 2012 Carnegie Institution for Science. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractSubsystemFactory.vsl

package org.tair.db.locusdetail;


import java.sql.ResultSet;
import java.sql.SQLException;

import com.poesys.db.InvalidParametersException;
import com.poesys.db.pk.IPrimaryKey;


/**
 * <p>
 * A separate, shareable set of factory methods for all the locusdetail
 * classes, including JDBC data-setting, parameter-setting, and
 * primary-key-generation methods. This class is abstract and has a single
 * concrete subclass, LocusdetailFactory, that you can modify to override
 * the default behavior in the abstract class or implement an as-yet 
 * unimplemented method.
 * </p>
 * <p>
 * The subsystem that contains all the details relating to the loci
 * </p>
 * 
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractLocusdetailFactory {
  /**
   * Retrieve the LocusCdnaAlias data from the result set's current row and create
   * a LocusCdnaAlias object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusCdnaAlias instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusCdnaAlias getLocusCdnaAliasData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument cloneTairObjectId gets the JDBC value with a function call.
    java.lang.Long cloneTairObjectIdValue = rs.getLong("cloneTairObjectId");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument alias gets the JDBC value with a function call.
    java.lang.String aliasValue = rs.getString("alias");
    // LocusCdnaAlias has no lazily loaded members, so there is no need for Proxy.
    ILocusCdnaAlias newObject = 
      new LocusCdnaAlias(key, cloneTairObjectIdValue, locusTairObjectIdValue, aliasValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusCdnaAlias based on a result set that must contain
   * the LocusCdnaAlias primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusCdnaAlias CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusCdnaAliasPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusCdnaPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String aliasValue = rs.getString("alias");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "alias", aliasValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusCdnaAlias");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusCdnaAlias");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusCdnaAlias based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param alias the alias for the cDNA sequence
   * @param cloneTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusCdnaAlias CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusCdnaAliasPrimaryKey(java.lang.String alias, java.lang.Long cloneTairObjectId, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusCdnaPrimaryKey(cloneTairObjectId, locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("alias", alias));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusCdnaAlias");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusCdnaAlias");
    }
    return key;
  }

  /**
   * Retrieve the ProteinResourceLink data from the result set's current row and create
   * a ProteinResourceLink object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a ProteinResourceLink instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IProteinResourceLink getProteinResourceLinkData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument sequenceTairObjectId gets the JDBC value with a function call.
    java.lang.Long sequenceTairObjectIdValue = rs.getLong("sequenceTairObjectId");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // Constructor argument icon gets the JDBC value with a function call.
    java.lang.String iconValue = rs.getString("icon");
    // Constructor argument baseUrl gets the JDBC value with a function call.
    java.lang.String baseUrlValue = rs.getString("baseUrl");
    // Constructor argument urlVariable gets the JDBC value with a function call.
    java.lang.String urlVariableValue = rs.getString("urlVariable");
    // Constructor argument explanation gets the JDBC value with a function call.
    java.lang.String explanationValue = rs.getString("explanation");
    // ProteinResourceLink has no lazily loaded members, so there is no need for Proxy.
    IProteinResourceLink newObject = 
      new ProteinResourceLink(key, geneModelNameValue, locusTairObjectIdValue, sequenceTairObjectIdValue, nameValue, iconValue, baseUrlValue, urlVariableValue, explanationValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a ProteinResourceLink based on a result set that must contain
   * the ProteinResourceLink primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a ProteinResourceLink CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getProteinResourceLinkPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getProteinModelPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String nameValue = rs.getString("name");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "name", nameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ProteinResourceLink");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ProteinResourceLink");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a ProteinResourceLink based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param geneModelName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param name the text name for the link, which usually includes the web site name and any
specific information in the context of the locus; the URL itself may be this
name if there is no other name
   * @param sequenceTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a ProteinResourceLink CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getProteinResourceLinkPrimaryKey(java.lang.String geneModelName, java.lang.Long locusTairObjectId, java.lang.String name, java.lang.Long sequenceTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getProteinModelPrimaryKey(geneModelName, locusTairObjectId, sequenceTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("name", name));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ProteinResourceLink");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ProteinResourceLink");
    }
    return key;
  }

  /**
   * Retrieve the LocusDetail data from the result set's current row and create
   * a LocusDetail object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusDetail instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusDetail getLocusDetailData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument locusName gets the JDBC value with a function call.
    java.lang.String locusNameValue = rs.getString("locusName");
    // Constructor argument primarySymbol gets the JDBC value with a function call.
    java.lang.String primarySymbolValue = rs.getString("primarySymbol");
    // Constructor argument primarySymbolFullName gets the JDBC value with a function call.
    java.lang.String primarySymbolFullNameValue = rs.getString("primarySymbolFullName");
    // Constructor argument chromosome gets the JDBC value with a function call.
    java.lang.String chromosomeValue = rs.getString("chromosome");
    // Constructor argument spanStartPosition gets the JDBC value with a function call.
    java.lang.Long spanStartPositionValue = rs.getLong("spanStartPosition");
    // Constructor argument spanEndPosition gets the JDBC value with a function call.
    java.lang.Long spanEndPositionValue = rs.getLong("spanEndPosition");
    // Constructor argument curatedSummary gets the JDBC value with a function call.
    java.lang.String curatedSummaryValue = rs.getString("curatedSummary");
    // Constructor argument geneModelCount gets the JDBC value with a function call.
    java.lang.Long geneModelCountValue = rs.getLong("geneModelCount");
    // Constructor argument polymorphismCount gets the JDBC value with a function call.
    java.lang.Long polymorphismCountValue = rs.getLong("polymorphismCount");
    // Constructor argument articleCount gets the JDBC value with a function call.
    java.lang.Long articleCountValue = rs.getLong("articleCount");
    // Constructor argument abstractCount gets the JDBC value with a function call.
    java.lang.Long abstractCountValue = rs.getLong("abstractCount");
    // Constructor argument geneFamilyName gets the JDBC value with a function call.
    java.lang.String geneFamilyNameValue = rs.getString("geneFamilyName");
    // Constructor argument geneFamilyTairObjectId gets the JDBC value with a function call.
    java.lang.Long geneFamilyTairObjectIdValue = rs.getLong("geneFamilyTairObjectId");
    if (rs.wasNull()) {
      geneFamilyTairObjectIdValue = null;
    };
    // Constructor argument taxonId gets the JDBC value with a function call.
    java.lang.Long taxonIdValue = rs.getLong("taxonId");
    // LocusDetail has lazily loaded members, so create a Proxy.
    ILocusDetail newObject = 
      new LocusDetailProxy(new LocusDetail(key, locusTairObjectIdValue, locusNameValue, primarySymbolValue, primarySymbolFullNameValue, chromosomeValue, spanStartPositionValue, spanEndPositionValue, curatedSummaryValue, geneModelCountValue, polymorphismCountValue, articleCountValue, abstractCountValue, geneFamilyNameValue, geneFamilyTairObjectIdValue, taxonIdValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusDetail based on a result set that must contain
   * the LocusDetail primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>NaturalKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusDetail NaturalKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusDetailPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");

    list.add(new com.poesys.db.col.LongColumnValue(prefix + "locusTairObjectId", locusTairObjectIdValue));
    key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusDetail");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusDetail based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>NaturalKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId unique identifier for the locus as a TAIR object
   * @return a LocusDetail NaturalKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusDetailPrimaryKey(java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    // Track generated inputs for nullity.
    boolean noNulls = true;
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    if (locusTairObjectId != null && noNulls) {
      list.add(new com.poesys.db.col.LongColumnValue("locusTairObjectId", locusTairObjectId));
    } else {
      noNulls = false;
    }
    if (noNulls) {
      key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusDetail");
    }
    return key;
  }

  /**
   * Retrieve the LocusUpdateHistory data from the result set's current row and create
   * a LocusUpdateHistory object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusUpdateHistory instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusUpdateHistory getLocusUpdateHistoryData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument updateType gets the JDBC value with a function call.
    java.lang.String updateTypeValue = rs.getString("updateType");
    // Constructor argument updateDate gets the JDBC value with a function call.
    java.sql.Timestamp updateDateValue = rs.getTimestamp("updateDate");
    // Constructor argument affectedTairObjectId gets the JDBC value with a function call.
    java.lang.Long affectedTairObjectIdValue = rs.getLong("affectedTairObjectId");
    if (rs.wasNull()) {
      affectedTairObjectIdValue = null;
    };
    // Constructor argument affectedTairObjectType gets the JDBC value with a function call.
    java.lang.String affectedTairObjectTypeValue = rs.getString("affectedTairObjectType");
    // Constructor argument affectedTairObjectName gets the JDBC value with a function call.
    java.lang.String affectedTairObjectNameValue = rs.getString("affectedTairObjectName");
    // LocusUpdateHistory has no lazily loaded members, so there is no need for Proxy.
    ILocusUpdateHistory newObject = 
      new LocusUpdateHistory(key, locusTairObjectIdValue, updateTypeValue, updateDateValue, affectedTairObjectIdValue, affectedTairObjectTypeValue, affectedTairObjectNameValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusUpdateHistory based on a result set that must contain
   * the LocusUpdateHistory primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusUpdateHistory CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusUpdateHistoryPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String updateTypeValue = rs.getString("updateType");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "updateType", updateTypeValue));
    java.sql.Timestamp updateDateValue = rs.getTimestamp("updateDate");
    list.add(new com.poesys.db.col.TimestampColumnValue(prefix + "updateDate", updateDateValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusUpdateHistory");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusUpdateHistory");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusUpdateHistory based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param updateDate the date and time of the update
   * @param updateType the type of update involved (obsoleted, added, replaces, split and added,
obsolete and replaced by, updated, replaced, restored, or blank)
   * @return a LocusUpdateHistory CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusUpdateHistoryPrimaryKey(java.lang.Long locusTairObjectId, java.sql.Timestamp updateDate, java.lang.String updateType)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("updateType", updateType));
      list.add(new com.poesys.db.col.TimestampColumnValue("updateDate", updateDate));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusUpdateHistory");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusUpdateHistory");
    }
    return key;
  }

  /**
   * Retrieve the LocusPhysicalMapCoordinates data from the result set's current row and create
   * a LocusPhysicalMapCoordinates object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusPhysicalMapCoordinates instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusPhysicalMapCoordinates getLocusPhysicalMapCoordinatesData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument mapId gets the JDBC value with a function call.
    java.lang.Long mapIdValue = rs.getLong("mapId");
    // Constructor argument mapName gets the JDBC value with a function call.
    java.lang.String mapNameValue = rs.getString("mapName");
    // Constructor argument mapType gets the JDBC value with a function call.
    java.lang.String mapTypeValue = rs.getString("mapType");
    // Constructor argument chromosome gets the JDBC value with a function call.
    java.lang.String chromosomeValue = rs.getString("chromosome");
    // Constructor argument startPosition gets the JDBC value with a function call.
    java.lang.Double startPositionValue = rs.getDouble("startPosition");
    // Constructor argument endPosition gets the JDBC value with a function call.
    java.lang.Double endPositionValue = rs.getDouble("endPosition");
    // Constructor argument units gets the JDBC value with a function call.
    java.lang.String unitsValue = rs.getString("units");
    // Constructor argument orientation gets the JDBC value with a function call.
    java.lang.String orientationValue = rs.getString("orientation");
    // LocusPhysicalMapCoordinates has no lazily loaded members, so there is no need for Proxy.
    ILocusPhysicalMapCoordinates newObject = 
      new LocusPhysicalMapCoordinates(key, locusTairObjectIdValue, mapIdValue, mapNameValue, mapTypeValue, chromosomeValue, startPositionValue, endPositionValue, unitsValue, orientationValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusPhysicalMapCoordinates based on a result set that must contain
   * the LocusPhysicalMapCoordinates primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusPhysicalMapCoordinates CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusPhysicalMapCoordinatesPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long mapIdValue = rs.getLong("mapId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "mapId", mapIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusPhysicalMapCoordinates");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusPhysicalMapCoordinates");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusPhysicalMapCoordinates based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param mapId the unique identifier for the map, also uniquely identifies the map coordinates
object within the parent TAIR object; used in the URL that displays the map
   * @return a LocusPhysicalMapCoordinates CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusPhysicalMapCoordinatesPrimaryKey(java.lang.Long locusTairObjectId, java.lang.Long mapId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.LongColumnValue("mapId", mapId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusPhysicalMapCoordinates");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusPhysicalMapCoordinates");
    }
    return key;
  }

  /**
   * Retrieve the LocusGeneModelCdnaAlias data from the result set's current row and create
   * a LocusGeneModelCdnaAlias object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusGeneModelCdnaAlias instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusGeneModelCdnaAlias getLocusGeneModelCdnaAliasData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument sequenceId gets the JDBC value with a function call.
    java.lang.Long sequenceIdValue = rs.getLong("sequenceId");
    // Constructor argument alias gets the JDBC value with a function call.
    java.lang.String aliasValue = rs.getString("alias");
    // LocusGeneModelCdnaAlias has no lazily loaded members, so there is no need for Proxy.
    ILocusGeneModelCdnaAlias newObject = 
      new LocusGeneModelCdnaAlias(key, geneModelNameValue, locusTairObjectIdValue, sequenceIdValue, aliasValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusGeneModelCdnaAlias based on a result set that must contain
   * the LocusGeneModelCdnaAlias primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusGeneModelCdnaAlias CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelCdnaAliasPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusGeneModelCdnaPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String aliasValue = rs.getString("alias");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "alias", aliasValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGeneModelCdnaAlias");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGeneModelCdnaAlias");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusGeneModelCdnaAlias based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param alias the alias for the cDNA sequence
   * @param geneModelName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param sequenceId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusGeneModelCdnaAlias CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelCdnaAliasPrimaryKey(java.lang.String alias, java.lang.String geneModelName, java.lang.Long locusTairObjectId, java.lang.Long sequenceId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusGeneModelCdnaPrimaryKey(geneModelName, locusTairObjectId, sequenceId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("alias", alias));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGeneModelCdnaAlias");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGeneModelCdnaAlias");
    }
    return key;
  }

  /**
   * Retrieve the LocusEstAlias data from the result set's current row and create
   * a LocusEstAlias object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusEstAlias instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusEstAlias getLocusEstAliasData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument cloneEndTairObjectId gets the JDBC value with a function call.
    java.lang.Long cloneEndTairObjectIdValue = rs.getLong("cloneEndTairObjectId");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument alias gets the JDBC value with a function call.
    java.lang.String aliasValue = rs.getString("alias");
    // LocusEstAlias has no lazily loaded members, so there is no need for Proxy.
    ILocusEstAlias newObject = 
      new LocusEstAlias(key, cloneEndTairObjectIdValue, locusTairObjectIdValue, aliasValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusEstAlias based on a result set that must contain
   * the LocusEstAlias primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusEstAlias CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusEstAliasPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocuslEstPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String aliasValue = rs.getString("alias");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "alias", aliasValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusEstAlias");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusEstAlias");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusEstAlias based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param alias the alias for the EST sequence
   * @param cloneEndTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusEstAlias CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusEstAliasPrimaryKey(java.lang.String alias, java.lang.Long cloneEndTairObjectId, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocuslEstPrimaryKey(cloneEndTairObjectId, locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("alias", alias));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusEstAlias");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusEstAlias");
    }
    return key;
  }

  /**
   * Retrieve the ReferencedLocus data from the result set's current row and create
   * a ReferencedLocus object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a ReferencedLocus instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IReferencedLocus getReferencedLocusData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument referenceTairObjectId gets the JDBC value with a function call.
    java.lang.Long referenceTairObjectIdValue = rs.getLong("referenceTairObjectId");
    // Constructor argument refLocusame gets the JDBC value with a function call.
    java.lang.String refLocusameValue = rs.getString("refLocusame");
    // Constructor argument refLocusTairObjectId gets the JDBC value with a function call.
    java.lang.Long refLocusTairObjectIdValue = rs.getLong("refLocusTairObjectId");
    // Constructor argument primarySymbol gets the JDBC value with a function call.
    java.lang.String primarySymbolValue = rs.getString("primarySymbol");
    // Constructor argument primarySymbolFullName gets the JDBC value with a function call.
    java.lang.String primarySymbolFullNameValue = rs.getString("primarySymbolFullName");
    // ReferencedLocus has no lazily loaded members, so there is no need for Proxy.
    IReferencedLocus newObject = 
      new ReferencedLocus(key, locusTairObjectIdValue, referenceTairObjectIdValue, refLocusameValue, refLocusTairObjectIdValue, primarySymbolValue, primarySymbolFullNameValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a ReferencedLocus based on a result set that must contain
   * the ReferencedLocus primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a ReferencedLocus CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getReferencedLocusPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getReferencePrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String refLocusameValue = rs.getString("refLocusame");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "refLocusame", refLocusameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ReferencedLocus");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ReferencedLocus");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a ReferencedLocus based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param refLocusame the unique name for the locus
   * @param referenceTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a ReferencedLocus CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getReferencedLocusPrimaryKey(java.lang.Long locusTairObjectId, java.lang.String refLocusame, java.lang.Long referenceTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getReferencePrimaryKey(locusTairObjectId, referenceTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("refLocusame", refLocusame));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ReferencedLocus");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ReferencedLocus");
    }
    return key;
  }

  /**
   * Retrieve the LocusBac data from the result set's current row and create
   * a LocusBac object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusBac instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusBac getLocusBacData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument bacTairObjectId gets the JDBC value with a function call.
    java.lang.Long bacTairObjectIdValue = rs.getLong("bacTairObjectId");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // Constructor argument icAccession gets the JDBC value with a function call.
    java.lang.String icAccessionValue = rs.getString("icAccession");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Long lengthValue = rs.getLong("length");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Long startValue = rs.getLong("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Long endValue = rs.getLong("endPosition");
    // Constructor argument cloneTairObjectId gets the JDBC value with a function call.
    java.lang.Long cloneTairObjectIdValue = rs.getLong("cloneTairObjectId");
    // LocusBac has no lazily loaded members, so there is no need for Proxy.
    ILocusBac newObject = 
      new LocusBac(key, locusTairObjectIdValue, bacTairObjectIdValue, nameValue, icAccessionValue, lengthValue, startValue, endValue, cloneTairObjectIdValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusBac based on a result set that must contain
   * the LocusBac primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusBac CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusBacPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long bacTairObjectIdValue = rs.getLong("bacTairObjectId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "bacTairObjectId", bacTairObjectIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusBac");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusBac");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusBac based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param bacTairObjectId the unique TAIR object identifier for the BAC (assembly unit)
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusBac CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusBacPrimaryKey(java.lang.Long bacTairObjectId, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.LongColumnValue("bacTairObjectId", bacTairObjectId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusBac");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusBac");
    }
    return key;
  }

  /**
   * Retrieve the LocusAttribution data from the result set's current row and create
   * a LocusAttribution object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusAttribution instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusAttribution getLocusAttributionData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument locusAttributionNo gets the JDBC value with a function call.
    java.math.BigInteger locusAttributionNoValue = rs.getBigDecimal("locusAttributionNo") == null ? null : rs.getBigDecimal("locusAttributionNo").toBigInteger();;
    // Constructor argument attributionType gets the JDBC value with a function call.
    java.lang.String attributionTypeValue = rs.getString("attributionType");
    // Constructor argument linkType gets the JDBC value with a function call.
    java.lang.String linkTypeValue = rs.getString("linkType");
    // Constructor argument communityId gets the JDBC value with a function call.
    java.lang.Long communityIdValue = rs.getLong("communityId");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // Constructor argument attributionDate gets the JDBC value with a function call.
    java.sql.Timestamp attributionDateValue = rs.getTimestamp("attributionDate");
    if (rs.wasNull()) {
      attributionDateValue = null;
    };
    // LocusAttribution has no lazily loaded members, so there is no need for Proxy.
    ILocusAttribution newObject = 
      new LocusAttribution(key, locusTairObjectIdValue, locusAttributionNoValue, attributionTypeValue, linkTypeValue, communityIdValue, nameValue, attributionDateValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusAttribution based on a result set that must contain
   * the LocusAttribution primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusAttribution CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusAttributionPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.math.BigInteger locusAttributionNoValue = rs.getBigDecimal("locusAttributionNo") == null ? null : rs.getBigDecimal("locusAttributionNo").toBigInteger();;
    list.add(new com.poesys.db.col.BigIntegerColumnValue(prefix + "locusAttributionNo", locusAttributionNoValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusAttribution");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusAttribution");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusAttribution based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusAttributionNo composite subkey attribute that uniquely identifies child combined with parent key
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusAttribution CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusAttributionPrimaryKey(java.math.BigInteger locusAttributionNo, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.BigIntegerColumnValue("locusAttributionNo", locusAttributionNo));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusAttribution");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusAttribution");
    }
    return key;
  }

  /**
   * Retrieve the Annotation data from the result set's current row and create
   * a Annotation object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a Annotation instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IAnnotation getAnnotationData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument category gets the JDBC value with a function call.
    java.lang.String categoryValue = rs.getString("category");
    // Constructor argument relationshipType gets the JDBC value with a function call.
    java.lang.String relationshipTypeValue = rs.getString("relationshipType");
    // Constructor argument keyword gets the JDBC value with a function call.
    java.lang.String keywordValue = rs.getString("keyword");
    // Constructor argument evidenceCode gets the JDBC value with a function call.
    java.lang.String evidenceCodeValue = rs.getString("evidenceCode");
    // Constructor argument evidenceWith gets the JDBC value with a function call.
    java.lang.String evidenceWithValue = rs.getString("evidenceWith");
    // Constructor argument reference gets the JDBC value with a function call.
    java.lang.String referenceValue = rs.getString("reference");
    // Constructor argument keywordId gets the JDBC value with a function call.
    java.lang.Long keywordIdValue = rs.getLong("keywordId");
    // Constructor argument ontologyId gets the JDBC value with a function call.
    java.lang.String ontologyIdValue = rs.getString("ontologyId");
    // Constructor argument evidenceDescription gets the JDBC value with a function call.
    java.lang.String evidenceDescriptionValue = rs.getString("evidenceDescription");
    // Constructor argument evidenceId gets the JDBC value with a function call.
    java.lang.Long evidenceIdValue = rs.getLong("evidenceId");
    // Constructor argument referenceId gets the JDBC value with a function call.
    java.lang.Long referenceIdValue = rs.getLong("referenceId");
    // Constructor argument annotatedBy gets the JDBC value with a function call.
    java.lang.String annotatedByValue = rs.getString("annotatedBy");
    // Annotation has lazily loaded members, so create a Proxy.
    IAnnotation newObject = 
      new AnnotationProxy(new Annotation(key, categoryValue, relationshipTypeValue, keywordValue, evidenceCodeValue, evidenceWithValue, referenceValue, keywordIdValue, ontologyIdValue, evidenceDescriptionValue, evidenceIdValue, referenceIdValue, annotatedByValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a Annotation based on a result set that must contain
   * the Annotation primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>NaturalKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a Annotation NaturalKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getAnnotationPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String categoryValue = rs.getString("category");

    list.add(new com.poesys.db.col.StringColumnValue(prefix + "category", categoryValue));
    java.lang.String evidenceCodeValue = rs.getString("evidenceCode");

    list.add(new com.poesys.db.col.StringColumnValue(prefix + "evidenceCode", evidenceCodeValue));
    java.lang.String evidenceWithValue = rs.getString("evidenceWith");

    list.add(new com.poesys.db.col.StringColumnValue(prefix + "evidenceWith", evidenceWithValue));
    java.lang.String keywordValue = rs.getString("keyword");

    list.add(new com.poesys.db.col.StringColumnValue(prefix + "keyword", keywordValue));
    java.lang.String referenceValue = rs.getString("reference");

    list.add(new com.poesys.db.col.StringColumnValue(prefix + "reference", referenceValue));
    java.lang.String relationshipTypeValue = rs.getString("relationshipType");

    list.add(new com.poesys.db.col.StringColumnValue(prefix + "relationshipType", relationshipTypeValue));
    key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.Annotation");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a Annotation based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>NaturalKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param category The kind of keyword (GO Biological Process, GO Cellular Component, GO Molecular
Function, Interaction, Expression, Growth and Developmental Stages, Plant
Structure)
   * @param evidenceCode the standard three-letter code that indicates the kind of evidence association
with the annotation, such as IEA (inferred from electronic annotation) or IDA
(inferred from direct assay).
   * @param evidenceWith information associated with the evidence, such as an affected protein or gene
   * @param keyword the keyword associated with the locus (such as nucleus, glucose mediated
signaling pathway, or dry seed stage)
   * @param reference the reference (publication, communication, etc.) from which the annotation
comes; this is a textual version of the reference used for display
   * @param relationshipType The kind of relationship between a locus and a keyword (such as involved in,
located in, functions in, has, not expressed during, or expressed in)
   * @return a Annotation NaturalKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getAnnotationPrimaryKey(java.lang.String category, java.lang.String evidenceCode, java.lang.String evidenceWith, java.lang.String keyword, java.lang.String reference, java.lang.String relationshipType)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    // Track generated inputs for nullity.
    boolean noNulls = true;
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    if (category != null && noNulls) {
      list.add(new com.poesys.db.col.StringColumnValue("category", category));
    } else {
      noNulls = false;
    }
    if (evidenceCode != null && noNulls) {
      list.add(new com.poesys.db.col.StringColumnValue("evidenceCode", evidenceCode));
    } else {
      noNulls = false;
    }
    if (evidenceWith != null && noNulls) {
      list.add(new com.poesys.db.col.StringColumnValue("evidenceWith", evidenceWith));
    } else {
      noNulls = false;
    }
    if (keyword != null && noNulls) {
      list.add(new com.poesys.db.col.StringColumnValue("keyword", keyword));
    } else {
      noNulls = false;
    }
    if (reference != null && noNulls) {
      list.add(new com.poesys.db.col.StringColumnValue("reference", reference));
    } else {
      noNulls = false;
    }
    if (relationshipType != null && noNulls) {
      list.add(new com.poesys.db.col.StringColumnValue("relationshipType", relationshipType));
    } else {
      noNulls = false;
    }
    if (noNulls) {
      key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.Annotation");
    }
    return key;
  }

  /**
   * Retrieve the LocusGeneModel data from the result set's current row and create
   * a LocusGeneModel object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusGeneModel instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusGeneModel getLocusGeneModelData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument geneModelType gets the JDBC value with a function call.
    java.lang.String geneModelTypeValue = rs.getString("geneModelType");
    // Constructor argument representative gets the JDBC value with a function call.
    java.lang.Boolean representativeValue = rs.getBoolean("representative");
    // Constructor argument spliceVariant gets the JDBC value with a function call.
    java.lang.Boolean spliceVariantValue = rs.getBoolean("spliceVariant");
    // Constructor argument computationalDescription gets the JDBC value with a function call.
    java.lang.String computationalDescriptionValue = rs.getString("computationalDescription");
    // Constructor argument curatedSummary gets the JDBC value with a function call.
    java.lang.String curatedSummaryValue = rs.getString("curatedSummary");
    // Constructor argument confidence gets the JDBC value with a function call.
    java.lang.String confidenceValue = rs.getString("confidence");
    // LocusGeneModel has lazily loaded members, so create a Proxy.
    ILocusGeneModel newObject = 
      new LocusGeneModelProxy(new LocusGeneModel(key, locusTairObjectIdValue, geneModelNameValue, geneModelTypeValue, representativeValue, spliceVariantValue, computationalDescriptionValue, curatedSummaryValue, confidenceValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusGeneModel based on a result set that must contain
   * the LocusGeneModel primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusGeneModel CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "geneModelName", geneModelNameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGeneModel");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGeneModel");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusGeneModel based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param geneModelName gene model name; usually in the format ATcGnnnnn.n, where the first part is the
locus name and the part following the dot is the model number; unique within the
locus
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusGeneModel CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelPrimaryKey(java.lang.String geneModelName, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("geneModelName", geneModelName));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGeneModel");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGeneModel");
    }
    return key;
  }

  /**
   * Retrieve the Reference data from the result set's current row and create
   * a Reference object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a Reference instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IReference getReferenceData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument referenceTairObjectId gets the JDBC value with a function call.
    java.lang.Long referenceTairObjectIdValue = rs.getLong("referenceTairObjectId");
    // Constructor argument title gets the JDBC value with a function call.
    java.lang.String titleValue = rs.getString("title");
    // Constructor argument authors gets the JDBC value with a function call.
    java.lang.String authorsValue = rs.getString("authors");
    // Constructor argument publicationYear gets the JDBC value with a function call.
    java.lang.Integer publicationYearValue = rs.getInt("publicationYear");
    // Constructor argument locusCount gets the JDBC value with a function call.
    java.lang.Integer locusCountValue = rs.getInt("locusCount");
    // Constructor argument annotated gets the JDBC value with a function call.
    java.lang.Boolean annotatedValue = rs.getBoolean("annotated");
    // Reference has lazily loaded members, so create a Proxy.
    IReference newObject = 
      new ReferenceProxy(new Reference(key, locusTairObjectIdValue, referenceTairObjectIdValue, titleValue, authorsValue, publicationYearValue, locusCountValue, annotatedValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a Reference based on a result set that must contain
   * the Reference primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a Reference CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getReferencePrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long referenceTairObjectIdValue = rs.getLong("referenceTairObjectId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "referenceTairObjectId", referenceTairObjectIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.Reference");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.Reference");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a Reference based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param referenceTairObjectId the unique TAIR object identifier for the reference; used to link to the
reference page
   * @return a Reference CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getReferencePrimaryKey(java.lang.Long locusTairObjectId, java.lang.Long referenceTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.LongColumnValue("referenceTairObjectId", referenceTairObjectId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.Reference");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.Reference");
    }
    return key;
  }

  /**
   * Retrieve the LocusGeneModelAnnotation data from the result set's current row and create
   * a LocusGeneModelAnnotation object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusGeneModelAnnotation instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusGeneModelAnnotation getLocusGeneModelAnnotationData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.IAnnotation annotationsObject = null;
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.ILocusGeneModel geneModelsObject = null;
    // Constructor argument category gets the JDBC value with a function call.
    java.lang.String categoryValue = rs.getString("category");
    // Constructor argument evidenceCode gets the JDBC value with a function call.
    java.lang.String evidenceCodeValue = rs.getString("evidenceCode");
    // Constructor argument evidenceWith gets the JDBC value with a function call.
    java.lang.String evidenceWithValue = rs.getString("evidenceWith");
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument keyword gets the JDBC value with a function call.
    java.lang.String keywordValue = rs.getString("keyword");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument reference gets the JDBC value with a function call.
    java.lang.String referenceValue = rs.getString("reference");
    // Constructor argument relationshipType gets the JDBC value with a function call.
    java.lang.String relationshipTypeValue = rs.getString("relationshipType");
    // LocusGeneModelAnnotation has no lazily loaded members, so there is no need for Proxy.
    ILocusGeneModelAnnotation newObject = 
      new LocusGeneModelAnnotation(key, annotationsObject, geneModelsObject, categoryValue, evidenceCodeValue, evidenceWithValue, geneModelNameValue, keywordValue, locusTairObjectIdValue, referenceValue, relationshipTypeValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusGeneModelAnnotation based on a result set that must contain
   * the LocusGeneModelAnnotation primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusGeneModelAnnotation AssociationKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelAnnotationPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> annotationsKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String categoryValue = rs.getString("category");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "category", categoryValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String evidenceCodeValue = rs.getString("evidenceCode");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "evidenceCode", evidenceCodeValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String evidenceWithValue = rs.getString("evidenceWith");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "evidenceWith", evidenceWithValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String keywordValue = rs.getString("keyword");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "keyword", keywordValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String referenceValue = rs.getString("reference");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "reference", referenceValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String relationshipTypeValue = rs.getString("relationshipType");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "relationshipType", relationshipTypeValue));
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(annotationsKeys, "org.tair.db.locusdetail.LocusGeneModelAnnotation"));
    IPrimaryKey geneModelsKey = getLocusDetailPrimaryKey(rs, prefix + "geneModels");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> geneModelsKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddExplicitSubKeyProperties + addNaturalSubkeyOnClass + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    
    geneModelsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "geneModelName", geneModelNameValue));
    // Property source: AddNaturalKeyProperties + AddParentKeyAttributes + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    
    geneModelsKeys.add(new com.poesys.db.col.LongColumnValue(prefix + "locusTairObjectId", locusTairObjectIdValue));
	IPrimaryKey geneModelsSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(geneModelsKeys, "org.tair.db.locusdetail.LocusGeneModelAnnotation");
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(geneModelsKey, geneModelsSubKey, "org.tair.db.locusdetail.LocusGeneModelAnnotation"));
	key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.LocusGeneModelAnnotation");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusGeneModelAnnotation based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param category Attribute that is part of the association key
   * @param evidenceCode Attribute that is part of the association key
   * @param evidenceWith Attribute that is part of the association key
   * @param geneModelName Attribute that is part of the association key
   * @param keyword Attribute that is part of the association key
   * @param locusTairObjectId Attribute that is part of the association key
   * @param reference Attribute that is part of the association key
   * @param relationshipType Attribute that is part of the association key
   * @return a LocusGeneModelAnnotation AssociationKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelAnnotationPrimaryKey(java.lang.String category, java.lang.String evidenceCode, java.lang.String evidenceWith, java.lang.String geneModelName, java.lang.String keyword, java.lang.Long locusTairObjectId, java.lang.String reference, java.lang.String relationshipType)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    // Track whether any input keys are null.
    boolean noNulls = true;
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> annotationsKeys =
      new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    if (category != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("category", category));
    } else {
      noNulls = false;
    }
    if (evidenceCode != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("evidenceCode", evidenceCode));
    } else {
      noNulls = false;
    }
    if (evidenceWith != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("evidenceWith", evidenceWith));
    } else {
      noNulls = false;
    }
    if (keyword != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("keyword", keyword));
    } else {
      noNulls = false;
    }
    if (reference != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("reference", reference));
    } else {
      noNulls = false;
    }
    if (relationshipType != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("relationshipType", relationshipType));
    } else {
      noNulls = false;
    }
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(annotationsKeys, "org.tair.db.locusdetail.LocusGeneModelAnnotation"));
    IPrimaryKey geneModelsParentKey = getLocusDetailPrimaryKey(locusTairObjectId);
    if (geneModelsParentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> geneModelsLocusDetailList =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
	  IPrimaryKey geneModelsSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(geneModelsLocusDetailList, "org.tair.db.locusdetail.LocusGeneModelAnnotation");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(geneModelsParentKey, geneModelsSubKey, "org.tair.db.locusdetail.LocusGeneModelAnnotation");
    } else {
      noNulls = false;
    }
    if (noNulls) {
	  key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.LocusGeneModelAnnotation");
	}
    return key;
  }

  /**
   * Retrieve the ConferenceAbstract data from the result set's current row and create
   * a ConferenceAbstract object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a ConferenceAbstract instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IConferenceAbstract getConferenceAbstractData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument referenceTairObjectId gets the JDBC value with a function call.
    java.lang.Long referenceTairObjectIdValue = rs.getLong("referenceTairObjectId");
    // Constructor argument title gets the JDBC value with a function call.
    java.lang.String titleValue = rs.getString("title");
    // Constructor argument authors gets the JDBC value with a function call.
    java.lang.String authorsValue = rs.getString("authors");
    // Constructor argument publicationYear gets the JDBC value with a function call.
    java.lang.Integer publicationYearValue = rs.getInt("publicationYear");
    // Constructor argument locusCount gets the JDBC value with a function call.
    java.lang.Integer locusCountValue = rs.getInt("locusCount");
    // Constructor argument annotated gets the JDBC value with a function call.
    java.lang.Boolean annotatedValue = rs.getBoolean("annotated");
    // Constructor argument conference gets the JDBC value with a function call.
    java.lang.String conferenceValue = rs.getString("conference");
    // ConferenceAbstract has lazily loaded members, so create a Proxy.
    IConferenceAbstract newObject = 
      new ConferenceAbstractProxy(new ConferenceAbstract(key, locusTairObjectIdValue, referenceTairObjectIdValue, titleValue, authorsValue, publicationYearValue, locusCountValue, annotatedValue, conferenceValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a ConferenceAbstract based on a result set that must contain
   * the ConferenceAbstract primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a ConferenceAbstract None primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getConferenceAbstractPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    key = org.tair.db.locusdetail.LocusdetailFactory.getReferencePrimaryKey(rs, "");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a ConferenceAbstract based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param referenceTairObjectId the unique TAIR object identifier for the reference; used to link to the
reference page
   * @return a ConferenceAbstract None primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getConferenceAbstractPrimaryKey(java.lang.Long locusTairObjectId, java.lang.Long referenceTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    key = org.tair.db.locusdetail.LocusdetailFactory.getReferencePrimaryKey(locusTairObjectId, referenceTairObjectId);
    return key;
  }

  /**
   * Retrieve the LocusInducedPolymorphism data from the result set's current row and create
   * a LocusInducedPolymorphism object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusInducedPolymorphism instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusInducedPolymorphism getLocusInducedPolymorphismData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument polymorphismName gets the JDBC value with a function call.
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    // Constructor argument polymorphismTairObjectId gets the JDBC value with a function call.
    java.lang.Long polymorphismTairObjectIdValue = rs.getLong("polymorphismTairObjectId");
    // Constructor argument polymorphismType gets the JDBC value with a function call.
    java.lang.String polymorphismTypeValue = rs.getString("polymorphismType");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Long lengthValue = rs.getLong("length");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Long startValue = rs.getLong("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Long endValue = rs.getLong("endPosition");
    // Constructor argument inheritance gets the JDBC value with a function call.
    java.lang.String inheritanceValue = rs.getString("inheritance");
    // Constructor argument alleleType gets the JDBC value with a function call.
    java.lang.String alleleTypeValue = rs.getString("alleleType");
    // Constructor argument accession gets the JDBC value with a function call.
    java.lang.String accessionValue = rs.getString("accession");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // Constructor argument taxonId gets the JDBC value with a function call.
    java.lang.Long taxonIdValue = rs.getLong("taxonId");
    // LocusInducedPolymorphism has lazily loaded members, so create a Proxy.
    ILocusInducedPolymorphism newObject = 
      new LocusInducedPolymorphismProxy(new LocusInducedPolymorphism(key, locusTairObjectIdValue, polymorphismNameValue, polymorphismTairObjectIdValue, polymorphismTypeValue, lengthValue, startValue, endValue, inheritanceValue, alleleTypeValue, accessionValue, nameValue, taxonIdValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusInducedPolymorphism based on a result set that must contain
   * the LocusInducedPolymorphism primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusInducedPolymorphism None primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusInducedPolymorphismPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    key = org.tair.db.locusdetail.LocusdetailFactory.getLocusPolymorphismPrimaryKey(rs, "");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusInducedPolymorphism based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param polymorphismName the name of the polymorphism
   * @return a LocusInducedPolymorphism None primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusInducedPolymorphismPrimaryKey(java.lang.Long locusTairObjectId, java.lang.String polymorphismName)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    key = org.tair.db.locusdetail.LocusdetailFactory.getLocusPolymorphismPrimaryKey(locusTairObjectId, polymorphismName);
    return key;
  }

  /**
   * Retrieve the LocusGeneModelCdna data from the result set's current row and create
   * a LocusGeneModelCdna object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusGeneModelCdna instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusGeneModelCdna getLocusGeneModelCdnaData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument sequenceId gets the JDBC value with a function call.
    java.lang.Long sequenceIdValue = rs.getLong("sequenceId");
    // Constructor argument sequenceName gets the JDBC value with a function call.
    java.lang.String sequenceNameValue = rs.getString("sequenceName");
    // Constructor argument icAccession gets the JDBC value with a function call.
    java.lang.String icAccessionValue = rs.getString("icAccession");
    // Constructor argument vectorType gets the JDBC value with a function call.
    java.lang.String vectorTypeValue = rs.getString("vectorType");
    // Constructor argument fullLengthCds gets the JDBC value with a function call.
    java.lang.Boolean fullLengthCdsValue = rs.getBoolean("fullLengthCds");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Long lengthValue = rs.getLong("length");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Long startValue = rs.getLong("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Long endValue = rs.getLong("endPosition");
    // LocusGeneModelCdna has no lazily loaded members, so there is no need for Proxy.
    ILocusGeneModelCdna newObject = 
      new LocusGeneModelCdna(key, geneModelNameValue, locusTairObjectIdValue, sequenceIdValue, sequenceNameValue, icAccessionValue, vectorTypeValue, fullLengthCdsValue, lengthValue, startValue, endValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusGeneModelCdna based on a result set that must contain
   * the LocusGeneModelCdna primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusGeneModelCdna CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelCdnaPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusGeneModelPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long sequenceIdValue = rs.getLong("sequenceId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "sequenceId", sequenceIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGeneModelCdna");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGeneModelCdna");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusGeneModelCdna based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param geneModelName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param sequenceId the unique identifier for the cDNA
   * @return a LocusGeneModelCdna CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGeneModelCdnaPrimaryKey(java.lang.String geneModelName, java.lang.Long locusTairObjectId, java.lang.Long sequenceId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusGeneModelPrimaryKey(geneModelName, locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.LongColumnValue("sequenceId", sequenceId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGeneModelCdna");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGeneModelCdna");
    }
    return key;
  }

  /**
   * Retrieve the ProteinModel data from the result set's current row and create
   * a ProteinModel object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a ProteinModel instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IProteinModel getProteinModelData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument sequenceTairObjectId gets the JDBC value with a function call.
    java.lang.Long sequenceTairObjectIdValue = rs.getLong("sequenceTairObjectId");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Integer lengthValue = rs.getInt("length");
    // Constructor argument molecularWeight gets the JDBC value with a function call.
    java.lang.Double molecularWeightValue = rs.getDouble("molecularWeight");
    if (rs.wasNull()) {
      molecularWeightValue = null;
    };
    // Constructor argument isoelectricPoint gets the JDBC value with a function call.
    java.lang.Double isoelectricPointValue = rs.getDouble("isoelectricPoint");
    if (rs.wasNull()) {
      isoelectricPointValue = null;
    };
    // ProteinModel has lazily loaded members, so create a Proxy.
    IProteinModel newObject = 
      new ProteinModelProxy(new ProteinModel(key, geneModelNameValue, locusTairObjectIdValue, sequenceTairObjectIdValue, lengthValue, molecularWeightValue, isoelectricPointValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a ProteinModel based on a result set that must contain
   * the ProteinModel primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a ProteinModel CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getProteinModelPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusGeneModelPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long sequenceTairObjectIdValue = rs.getLong("sequenceTairObjectId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "sequenceTairObjectId", sequenceTairObjectIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ProteinModel");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ProteinModel");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a ProteinModel based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param geneModelName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param sequenceTairObjectId the TAIR object id for the sequence; used in links
   * @return a ProteinModel CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getProteinModelPrimaryKey(java.lang.String geneModelName, java.lang.Long locusTairObjectId, java.lang.Long sequenceTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusGeneModelPrimaryKey(geneModelName, locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.LongColumnValue("sequenceTairObjectId", sequenceTairObjectId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ProteinModel");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ProteinModel");
    }
    return key;
  }

  /**
   * Retrieve the ProteinModelDomain data from the result set's current row and create
   * a ProteinModelDomain object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a ProteinModelDomain instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IProteinModelDomain getProteinModelDomainData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.IDomain domainsObject = null;
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.IProteinModel modelsObject = null;
    // Constructor argument accession gets the JDBC value with a function call.
    java.lang.String accessionValue = rs.getString("accession");
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument sequenceTairObjectId gets the JDBC value with a function call.
    java.lang.Long sequenceTairObjectIdValue = rs.getLong("sequenceTairObjectId");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Integer startValue = rs.getInt("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Integer endValue = rs.getInt("endPosition");
    // ProteinModelDomain has no lazily loaded members, so there is no need for Proxy.
    IProteinModelDomain newObject = 
      new ProteinModelDomain(key, domainsObject, modelsObject, accessionValue, geneModelNameValue, locusTairObjectIdValue, sequenceTairObjectIdValue, startValue, endValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a ProteinModelDomain based on a result set that must contain
   * the ProteinModelDomain primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a ProteinModelDomain AssociationKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getProteinModelDomainPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> domainsKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String accessionValue = rs.getString("accession");
    domainsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "accession", accessionValue));
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(domainsKeys, "org.tair.db.locusdetail.ProteinModelDomain"));
    IPrimaryKey modelsKey = getLocusGeneModelPrimaryKey(rs, prefix + "models");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> modelsKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddExplicitSubKeyProperties + addNaturalSubkeyOnClass + AddParentKeyAttributes + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    
    modelsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "geneModelName", geneModelNameValue));
    // Property source: AddNaturalKeyProperties + AddParentKeyAttributes + AddParentKeyAttributes + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    
    modelsKeys.add(new com.poesys.db.col.LongColumnValue(prefix + "locusTairObjectId", locusTairObjectIdValue));
    // Property source: AddExplicitSubKeyProperties + addNaturalSubkeyOnClass + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.Long sequenceTairObjectIdValue = rs.getLong("sequenceTairObjectId");
    
    modelsKeys.add(new com.poesys.db.col.LongColumnValue(prefix + "sequenceTairObjectId", sequenceTairObjectIdValue));
	IPrimaryKey modelsSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(modelsKeys, "org.tair.db.locusdetail.ProteinModelDomain");
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(modelsKey, modelsSubKey, "org.tair.db.locusdetail.ProteinModelDomain"));
	key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.ProteinModelDomain");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a ProteinModelDomain based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param accession Attribute that is part of the association key
   * @param geneModelName Attribute that is part of the association key
   * @param locusTairObjectId Attribute that is part of the association key
   * @param sequenceTairObjectId Attribute that is part of the association key
   * @param start the starting position of the domain instance within the protein model; also part
of the primary key, so a protein may have multiple instances of a given domain
as long as the instances have a different start position
   * @return a ProteinModelDomain AssociationKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getProteinModelDomainPrimaryKey(java.lang.String accession, java.lang.String geneModelName, java.lang.Long locusTairObjectId, java.lang.Long sequenceTairObjectId, java.lang.Integer start)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    // Track whether any input keys are null.
    boolean noNulls = true;
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> domainsKeys =
      new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    if (accession != null && noNulls) {
      domainsKeys.add(new com.poesys.db.col.StringColumnValue("accession", accession));
    } else {
      noNulls = false;
    }
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(domainsKeys, "org.tair.db.locusdetail.ProteinModelDomain"));
    IPrimaryKey modelsParentKey = getLocusGeneModelPrimaryKey(geneModelName, locusTairObjectId);
    if (modelsParentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> modelsLocusGeneModelList =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
	  IPrimaryKey modelsSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(modelsLocusGeneModelList, "org.tair.db.locusdetail.ProteinModelDomain");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(modelsParentKey, modelsSubKey, "org.tair.db.locusdetail.ProteinModelDomain");
    } else {
      noNulls = false;
    }
    if (noNulls) {
	  key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.ProteinModelDomain");
	}
    return key;
  }

  /**
   * Retrieve the LocusAnnotation data from the result set's current row and create
   * a LocusAnnotation object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusAnnotation instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusAnnotation getLocusAnnotationData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.IAnnotation annotationsObject = null;
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.ILocusDetail lociObject = null;
    // Constructor argument category gets the JDBC value with a function call.
    java.lang.String categoryValue = rs.getString("category");
    // Constructor argument evidenceCode gets the JDBC value with a function call.
    java.lang.String evidenceCodeValue = rs.getString("evidenceCode");
    // Constructor argument evidenceWith gets the JDBC value with a function call.
    java.lang.String evidenceWithValue = rs.getString("evidenceWith");
    // Constructor argument keyword gets the JDBC value with a function call.
    java.lang.String keywordValue = rs.getString("keyword");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument reference gets the JDBC value with a function call.
    java.lang.String referenceValue = rs.getString("reference");
    // Constructor argument relationshipType gets the JDBC value with a function call.
    java.lang.String relationshipTypeValue = rs.getString("relationshipType");
    // LocusAnnotation has no lazily loaded members, so there is no need for Proxy.
    ILocusAnnotation newObject = 
      new LocusAnnotation(key, annotationsObject, lociObject, categoryValue, evidenceCodeValue, evidenceWithValue, keywordValue, locusTairObjectIdValue, referenceValue, relationshipTypeValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusAnnotation based on a result set that must contain
   * the LocusAnnotation primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusAnnotation AssociationKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusAnnotationPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> annotationsKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String categoryValue = rs.getString("category");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "category", categoryValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String evidenceCodeValue = rs.getString("evidenceCode");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "evidenceCode", evidenceCodeValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String evidenceWithValue = rs.getString("evidenceWith");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "evidenceWith", evidenceWithValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String keywordValue = rs.getString("keyword");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "keyword", keywordValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String referenceValue = rs.getString("reference");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "reference", referenceValue));
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String relationshipTypeValue = rs.getString("relationshipType");
    annotationsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "relationshipType", relationshipTypeValue));
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(annotationsKeys, "org.tair.db.locusdetail.LocusAnnotation"));
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> lociKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddNaturalKeyProperties + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    lociKeys.add(new com.poesys.db.col.LongColumnValue(prefix + "locusTairObjectId", locusTairObjectIdValue));
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(lociKeys, "org.tair.db.locusdetail.LocusAnnotation"));
	key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.LocusAnnotation");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusAnnotation based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param category Attribute that is part of the association key
   * @param evidenceCode Attribute that is part of the association key
   * @param evidenceWith Attribute that is part of the association key
   * @param keyword Attribute that is part of the association key
   * @param locusTairObjectId Attribute that is part of the association key
   * @param reference Attribute that is part of the association key
   * @param relationshipType Attribute that is part of the association key
   * @return a LocusAnnotation AssociationKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusAnnotationPrimaryKey(java.lang.String category, java.lang.String evidenceCode, java.lang.String evidenceWith, java.lang.String keyword, java.lang.Long locusTairObjectId, java.lang.String reference, java.lang.String relationshipType)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    // Track whether any input keys are null.
    boolean noNulls = true;
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> annotationsKeys =
      new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    if (category != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("category", category));
    } else {
      noNulls = false;
    }
    if (evidenceCode != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("evidenceCode", evidenceCode));
    } else {
      noNulls = false;
    }
    if (evidenceWith != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("evidenceWith", evidenceWith));
    } else {
      noNulls = false;
    }
    if (keyword != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("keyword", keyword));
    } else {
      noNulls = false;
    }
    if (reference != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("reference", reference));
    } else {
      noNulls = false;
    }
    if (relationshipType != null && noNulls) {
      annotationsKeys.add(new com.poesys.db.col.StringColumnValue("relationshipType", relationshipType));
    } else {
      noNulls = false;
    }
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(annotationsKeys, "org.tair.db.locusdetail.LocusAnnotation"));
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> lociKeys =
      new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    if (locusTairObjectId != null && noNulls) {
      lociKeys.add(new com.poesys.db.col.LongColumnValue("locusTairObjectId", locusTairObjectId));
    } else {
      noNulls = false;
    }
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(lociKeys, "org.tair.db.locusdetail.LocusAnnotation"));
    if (noNulls) {
	  key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.LocusAnnotation");
	}
    return key;
  }

  /**
   * Retrieve the LocusCdna data from the result set's current row and create
   * a LocusCdna object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusCdna instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusCdna getLocusCdnaData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument cloneTairObjectId gets the JDBC value with a function call.
    java.lang.Long cloneTairObjectIdValue = rs.getLong("cloneTairObjectId");
    // Constructor argument cloneName gets the JDBC value with a function call.
    java.lang.String cloneNameValue = rs.getString("cloneName");
    // Constructor argument icAccession gets the JDBC value with a function call.
    java.lang.String icAccessionValue = rs.getString("icAccession");
    // Constructor argument vectorType gets the JDBC value with a function call.
    java.lang.String vectorTypeValue = rs.getString("vectorType");
    // Constructor argument fullLengthCds gets the JDBC value with a function call.
    java.lang.Boolean fullLengthCdsValue = rs.getBoolean("fullLengthCds");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Long lengthValue = rs.getLong("length");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Long startValue = rs.getLong("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Long endValue = rs.getLong("endPosition");
    // LocusCdna has no lazily loaded members, so there is no need for Proxy.
    ILocusCdna newObject = 
      new LocusCdna(key, locusTairObjectIdValue, cloneTairObjectIdValue, cloneNameValue, icAccessionValue, vectorTypeValue, fullLengthCdsValue, lengthValue, startValue, endValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusCdna based on a result set that must contain
   * the LocusCdna primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusCdna CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusCdnaPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long cloneTairObjectIdValue = rs.getLong("cloneTairObjectId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "cloneTairObjectId", cloneTairObjectIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusCdna");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusCdna");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusCdna based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param cloneTairObjectId the unique identifier for the cDNA
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusCdna CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusCdnaPrimaryKey(java.lang.Long cloneTairObjectId, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.LongColumnValue("cloneTairObjectId", cloneTairObjectId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusCdna");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusCdna");
    }
    return key;
  }

  /**
   * Retrieve the Domain data from the result set's current row and create
   * a Domain object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a Domain instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IDomain getDomainData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument accession gets the JDBC value with a function call.
    java.lang.String accessionValue = rs.getString("accession");
    // Constructor argument accessionUrl gets the JDBC value with a function call.
    java.lang.String accessionUrlValue = rs.getString("accessionUrl");
    // Constructor argument domain gets the JDBC value with a function call.
    java.lang.String domainValue = rs.getString("domain");
    // Constructor argument domainUrl gets the JDBC value with a function call.
    java.lang.String domainUrlValue = rs.getString("domainUrl");
    // Constructor argument database gets the JDBC value with a function call.
    java.lang.String databaseValue = rs.getString("database");
    // Constructor argument databaseUrl gets the JDBC value with a function call.
    java.lang.String databaseUrlValue = rs.getString("databaseUrl");
    // Constructor argument structuralClassType gets the JDBC value with a function call.
    java.lang.String structuralClassTypeValue = rs.getString("structuralClassType");
    // Constructor argument classUrl gets the JDBC value with a function call.
    java.lang.String classUrlValue = rs.getString("classUrl");
    // Domain has lazily loaded members, so create a Proxy.
    IDomain newObject = 
      new DomainProxy(new Domain(key, accessionValue, accessionUrlValue, domainValue, domainUrlValue, databaseValue, databaseUrlValue, structuralClassTypeValue, classUrlValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a Domain based on a result set that must contain
   * the Domain primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>NaturalKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a Domain NaturalKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getDomainPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String accessionValue = rs.getString("accession");

    list.add(new com.poesys.db.col.StringColumnValue(prefix + "accession", accessionValue));
    key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.Domain");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a Domain based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>NaturalKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param accession a unique identifier for the protein domain, usually InterPro
   * @return a Domain NaturalKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getDomainPrimaryKey(java.lang.String accession)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    // Track generated inputs for nullity.
    boolean noNulls = true;
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    if (accession != null && noNulls) {
      list.add(new com.poesys.db.col.StringColumnValue("accession", accession));
    } else {
      noNulls = false;
    }
    if (noNulls) {
      key = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.Domain");
    }
    return key;
  }

  /**
   * Retrieve the JournalArticle data from the result set's current row and create
   * a JournalArticle object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a JournalArticle instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IJournalArticle getJournalArticleData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument referenceTairObjectId gets the JDBC value with a function call.
    java.lang.Long referenceTairObjectIdValue = rs.getLong("referenceTairObjectId");
    // Constructor argument title gets the JDBC value with a function call.
    java.lang.String titleValue = rs.getString("title");
    // Constructor argument authors gets the JDBC value with a function call.
    java.lang.String authorsValue = rs.getString("authors");
    // Constructor argument publicationYear gets the JDBC value with a function call.
    java.lang.Integer publicationYearValue = rs.getInt("publicationYear");
    // Constructor argument locusCount gets the JDBC value with a function call.
    java.lang.Integer locusCountValue = rs.getInt("locusCount");
    // Constructor argument annotated gets the JDBC value with a function call.
    java.lang.Boolean annotatedValue = rs.getBoolean("annotated");
    // Constructor argument journal gets the JDBC value with a function call.
    java.lang.String journalValue = rs.getString("journal");
    // Constructor argument pubmedId gets the JDBC value with a function call.
    java.lang.String pubmedIdValue = rs.getString("pubmedId");
    // JournalArticle has lazily loaded members, so create a Proxy.
    IJournalArticle newObject = 
      new JournalArticleProxy(new JournalArticle(key, locusTairObjectIdValue, referenceTairObjectIdValue, titleValue, authorsValue, publicationYearValue, locusCountValue, annotatedValue, journalValue, pubmedIdValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a JournalArticle based on a result set that must contain
   * the JournalArticle primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a JournalArticle None primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getJournalArticlePrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    key = org.tair.db.locusdetail.LocusdetailFactory.getReferencePrimaryKey(rs, "");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a JournalArticle based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param referenceTairObjectId the unique TAIR object identifier for the reference; used to link to the
reference page
   * @return a JournalArticle None primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getJournalArticlePrimaryKey(java.lang.Long locusTairObjectId, java.lang.Long referenceTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    key = org.tair.db.locusdetail.LocusdetailFactory.getReferencePrimaryKey(locusTairObjectId, referenceTairObjectId);
    return key;
  }

  /**
   * Retrieve the LocusComment data from the result set's current row and create
   * a LocusComment object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusComment instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusComment getLocusCommentData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument locusCommentNo gets the JDBC value with a function call.
    java.math.BigInteger locusCommentNoValue = rs.getBigDecimal("locusCommentNo") == null ? null : rs.getBigDecimal("locusCommentNo").toBigInteger();;
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // Constructor argument communityId gets the JDBC value with a function call.
    java.lang.Long communityIdValue = rs.getLong("communityId");
    // Constructor argument commentText gets the JDBC value with a function call.
    java.lang.String commentTextValue = rs.getString("commentText");
    // Constructor argument dateEntered gets the JDBC value with a function call.
    java.sql.Timestamp dateEnteredValue = rs.getTimestamp("dateEntered");
    // LocusComment has no lazily loaded members, so there is no need for Proxy.
    ILocusComment newObject = 
      new LocusComment(key, locusTairObjectIdValue, locusCommentNoValue, nameValue, communityIdValue, commentTextValue, dateEnteredValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusComment based on a result set that must contain
   * the LocusComment primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusComment CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusCommentPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.math.BigInteger locusCommentNoValue = rs.getBigDecimal("locusCommentNo") == null ? null : rs.getBigDecimal("locusCommentNo").toBigInteger();;
    list.add(new com.poesys.db.col.BigIntegerColumnValue(prefix + "locusCommentNo", locusCommentNoValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusComment");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusComment");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusComment based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusCommentNo composite subkey attribute that uniquely identifies child combined with parent key
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusComment CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusCommentPrimaryKey(java.math.BigInteger locusCommentNo, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.BigIntegerColumnValue("locusCommentNo", locusCommentNo));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusComment");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusComment");
    }
    return key;
  }

  /**
   * Retrieve the LocusNaturalVariation data from the result set's current row and create
   * a LocusNaturalVariation object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusNaturalVariation instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusNaturalVariation getLocusNaturalVariationData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument polymorphismName gets the JDBC value with a function call.
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    // Constructor argument polymorphismTairObjectId gets the JDBC value with a function call.
    java.lang.Long polymorphismTairObjectIdValue = rs.getLong("polymorphismTairObjectId");
    // Constructor argument polymorphismType gets the JDBC value with a function call.
    java.lang.String polymorphismTypeValue = rs.getString("polymorphismType");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Long lengthValue = rs.getLong("length");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Long startValue = rs.getLong("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Long endValue = rs.getLong("endPosition");
    // Constructor argument detail gets the JDBC value with a function call.
    java.lang.String detailValue = rs.getString("detail");
    // Constructor argument accession gets the JDBC value with a function call.
    java.lang.String accessionValue = rs.getString("referenceAccession");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("referenceEcotype");
    // Constructor argument taxonId gets the JDBC value with a function call.
    java.lang.Long taxonIdValue = rs.getLong("referenceTaxonId");
    // LocusNaturalVariation has lazily loaded members, so create a Proxy.
    ILocusNaturalVariation newObject = 
      new LocusNaturalVariationProxy(new LocusNaturalVariation(key, locusTairObjectIdValue, polymorphismNameValue, polymorphismTairObjectIdValue, polymorphismTypeValue, lengthValue, startValue, endValue, detailValue, accessionValue, nameValue, taxonIdValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusNaturalVariation based on a result set that must contain
   * the LocusNaturalVariation primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusNaturalVariation None primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusNaturalVariationPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    key = org.tair.db.locusdetail.LocusdetailFactory.getLocusPolymorphismPrimaryKey(rs, "");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusNaturalVariation based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param polymorphismName the name of the polymorphism
   * @return a LocusNaturalVariation None primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusNaturalVariationPrimaryKey(java.lang.Long locusTairObjectId, java.lang.String polymorphismName)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    key = org.tair.db.locusdetail.LocusdetailFactory.getLocusPolymorphismPrimaryKey(locusTairObjectId, polymorphismName);
    return key;
  }

  /**
   * Retrieve the PolymorphismSite data from the result set's current row and create
   * a PolymorphismSite object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a PolymorphismSite instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IPolymorphismSite getPolymorphismSiteData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.ILocusGeneModel lociObject = null;
    // Assign null to association key object, as this is set by QuerySetter
    org.tair.db.locusdetail.ILocusPolymorphism polymorphismsObject = null;
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("lociLocus");
    // Constructor argument lociLocusTairObjectId gets the JDBC value with a function call.
    java.lang.Long lociLocusTairObjectIdValue = rs.getLong("lociLocus");
    // Constructor argument polymorphismsLocusTairObjectId gets the JDBC value with a function call.
    java.lang.Long polymorphismsLocusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument polymorphismName gets the JDBC value with a function call.
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    // Constructor argument site gets the JDBC value with a function call.
    java.lang.String siteValue = rs.getString("site");
    // PolymorphismSite has no lazily loaded members, so there is no need for Proxy.
    IPolymorphismSite newObject = 
      new PolymorphismSite(key, lociObject, polymorphismsObject, geneModelNameValue, lociLocusTairObjectIdValue, polymorphismsLocusTairObjectIdValue, polymorphismNameValue, siteValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a PolymorphismSite based on a result set that must contain
   * the PolymorphismSite primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a PolymorphismSite AssociationKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getPolymorphismSitePrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    IPrimaryKey lociKey = getLocusDetailPrimaryKey(rs, prefix + "loci");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> lociKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddExplicitSubKeyProperties + addNaturalSubkeyOnClass + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String geneModelNameValue = rs.getString("lociLocus");
    
    lociKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "lociLocus", geneModelNameValue));
    // Property source: AddNaturalKeyProperties + AddParentKeyAttributes + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.Long lociLocusTairObjectIdValue = rs.getLong("lociLocus");
    
    lociKeys.add(new com.poesys.db.col.LongColumnValue(prefix + "lociLocus", lociLocusTairObjectIdValue));
	IPrimaryKey lociSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(lociKeys, "org.tair.db.locusdetail.PolymorphismSite");
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(lociKey, lociSubKey, "org.tair.db.locusdetail.PolymorphismSite"));
    IPrimaryKey polymorphismsKey = getLocusDetailPrimaryKey(rs, prefix + "polymorphisms");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> polymorphismsKeys =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    // Property source: AddNaturalKeyProperties + AddParentKeyAttributes + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.Long polymorphismsLocusTairObjectIdValue = rs.getLong("locusTairObjectId");
    
    polymorphismsKeys.add(new com.poesys.db.col.LongColumnValue(prefix + "locusTairObjectId", polymorphismsLocusTairObjectIdValue));
    // Property source: AddExplicitSubKeyProperties + addNaturalSubkeyOnClass + getAssociatedKeys
    // Owning DTO: $property.dto.name
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    
    polymorphismsKeys.add(new com.poesys.db.col.StringColumnValue(prefix + "polymorphismName", polymorphismNameValue));
	IPrimaryKey polymorphismsSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(polymorphismsKeys, "org.tair.db.locusdetail.PolymorphismSite");
    list.add(com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(polymorphismsKey, polymorphismsSubKey, "org.tair.db.locusdetail.PolymorphismSite"));
	key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.PolymorphismSite");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a PolymorphismSite based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>AssociationKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param geneModelName Attribute that is part of the association key
   * @param lociLocusTairObjectId Attribute that is part of the association key
   * @param polymorphismsLocusTairObjectId Attribute that is part of the association key
   * @param polymorphismName Attribute that is part of the association key
   * @return a PolymorphismSite AssociationKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getPolymorphismSitePrimaryKey(java.lang.String geneModelName, java.lang.Long lociLocusTairObjectId, java.lang.Long polymorphismsLocusTairObjectId, java.lang.String polymorphismName)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    // Track whether any input keys are null.
    boolean noNulls = true;
    java.util.ArrayList<IPrimaryKey> list =
        new java.util.ArrayList<IPrimaryKey>();
    IPrimaryKey lociParentKey = getLocusDetailPrimaryKey(lociLocusTairObjectId);
    if (lociParentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> lociLocusDetailList =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
	  IPrimaryKey lociSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(lociLocusDetailList, "org.tair.db.locusdetail.PolymorphismSite");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(lociParentKey, lociSubKey, "org.tair.db.locusdetail.PolymorphismSite");
    } else {
      noNulls = false;
    }
    IPrimaryKey polymorphismsParentKey = getLocusDetailPrimaryKey(polymorphismsLocusTairObjectId);
    if (polymorphismsParentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> polymorphismsLocusDetailList =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
	  IPrimaryKey polymorphismsSubKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(polymorphismsLocusDetailList, "org.tair.db.locusdetail.PolymorphismSite");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(polymorphismsParentKey, polymorphismsSubKey, "org.tair.db.locusdetail.PolymorphismSite");
    } else {
      noNulls = false;
    }
    if (noNulls) {
	  key = com.poesys.db.pk.PrimaryKeyFactory.createAssociationKey(list, "org.tair.db.locusdetail.PolymorphismSite");
	}
    return key;
  }

  /**
   * Retrieve the LocusPolymorphism data from the result set's current row and create
   * a LocusPolymorphism object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusPolymorphism instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusPolymorphism getLocusPolymorphismData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument polymorphismName gets the JDBC value with a function call.
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    // Constructor argument polymorphismTairObjectId gets the JDBC value with a function call.
    java.lang.Long polymorphismTairObjectIdValue = rs.getLong("polymorphismTairObjectId");
    // Constructor argument polymorphismType gets the JDBC value with a function call.
    java.lang.String polymorphismTypeValue = rs.getString("polymorphismType");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Long lengthValue = rs.getLong("length");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Long startValue = rs.getLong("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Long endValue = rs.getLong("endPosition");
    // LocusPolymorphism has lazily loaded members, so create a Proxy.
    ILocusPolymorphism newObject = 
      new LocusPolymorphismProxy(new LocusPolymorphism(key, locusTairObjectIdValue, polymorphismNameValue, polymorphismTairObjectIdValue, polymorphismTypeValue, lengthValue, startValue, endValue));
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusPolymorphism based on a result set that must contain
   * the LocusPolymorphism primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusPolymorphism CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusPolymorphismPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "polymorphismName", polymorphismNameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusPolymorphism");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusPolymorphism");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusPolymorphism based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param polymorphismName the name of the polymorphism
   * @return a LocusPolymorphism CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusPolymorphismPrimaryKey(java.lang.Long locusTairObjectId, java.lang.String polymorphismName)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("polymorphismName", polymorphismName));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusPolymorphism");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusPolymorphism");
    }
    return key;
  }

  /**
   * Retrieve the LocusResourceLink data from the result set's current row and create
   * a LocusResourceLink object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusResourceLink instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusResourceLink getLocusResourceLinkData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // Constructor argument linkType gets the JDBC value with a function call.
    java.lang.String linkTypeValue = rs.getString("linkType");
    // Constructor argument icon gets the JDBC value with a function call.
    java.lang.String iconValue = rs.getString("icon");
    // Constructor argument baseUrl gets the JDBC value with a function call.
    java.lang.String baseUrlValue = rs.getString("baseUrl");
    // Constructor argument urlVariable gets the JDBC value with a function call.
    java.lang.String urlVariableValue = rs.getString("urlVariable");
    // Constructor argument explanation gets the JDBC value with a function call.
    java.lang.String explanationValue = rs.getString("explanation");
    // LocusResourceLink has no lazily loaded members, so there is no need for Proxy.
    ILocusResourceLink newObject = 
      new LocusResourceLink(key, locusTairObjectIdValue, nameValue, linkTypeValue, iconValue, baseUrlValue, urlVariableValue, explanationValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusResourceLink based on a result set that must contain
   * the LocusResourceLink primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusResourceLink CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusResourceLinkPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String nameValue = rs.getString("name");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "name", nameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusResourceLink");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusResourceLink");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusResourceLink based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param name the text name for the link, which usually includes the web site name and any
specific information in the context of the locus; the URL itself may be this
name if there is no other name
   * @return a LocusResourceLink CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusResourceLinkPrimaryKey(java.lang.Long locusTairObjectId, java.lang.String name)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("name", name));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusResourceLink");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusResourceLink");
    }
    return key;
  }

  /**
   * Retrieve the LocusOtherSymbol data from the result set's current row and create
   * a LocusOtherSymbol object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusOtherSymbol instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusOtherSymbol getLocusOtherSymbolData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument symbol gets the JDBC value with a function call.
    java.lang.String symbolValue = rs.getString("symbol");
    // Constructor argument fullName gets the JDBC value with a function call.
    java.lang.String fullNameValue = rs.getString("fullName");
    // LocusOtherSymbol has no lazily loaded members, so there is no need for Proxy.
    ILocusOtherSymbol newObject = 
      new LocusOtherSymbol(key, locusTairObjectIdValue, symbolValue, fullNameValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusOtherSymbol based on a result set that must contain
   * the LocusOtherSymbol primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusOtherSymbol CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusOtherSymbolPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String symbolValue = rs.getString("symbol");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "symbol", symbolValue));
    java.lang.String fullNameValue = rs.getString("fullName");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "fullName", fullNameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusOtherSymbol");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusOtherSymbol");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusOtherSymbol based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param fullName the optional full name for the symbolic name for a gene or locus
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param symbol the symbol for the locus
   * @return a LocusOtherSymbol CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusOtherSymbolPrimaryKey(java.lang.String fullName, java.lang.Long locusTairObjectId, java.lang.String symbol)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("symbol", symbol));
      list.add(new com.poesys.db.col.StringColumnValue("fullName", fullName));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusOtherSymbol");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusOtherSymbol");
    }
    return key;
  }

  /**
   * Retrieve the ModelFeature data from the result set's current row and create
   * a ModelFeature object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a ModelFeature instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static IModelFeature getModelFeatureData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument geneModelName gets the JDBC value with a function call.
    java.lang.String geneModelNameValue = rs.getString("geneModelName");
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument featureType gets the JDBC value with a function call.
    java.lang.String featureTypeValue = rs.getString("featureType");
    // Constructor argument featureNumber gets the JDBC value with a function call.
    java.lang.Integer featureNumberValue = rs.getInt("featureNumber");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Integer startValue = rs.getInt("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Integer endValue = rs.getInt("endPosition");
    // Constructor argument agiStart gets the JDBC value with a function call.
    java.lang.Integer agiStartValue = rs.getInt("agiStart");
    // Constructor argument agiEnd gets the JDBC value with a function call.
    java.lang.Integer agiEndValue = rs.getInt("agiEnd");
    // ModelFeature has no lazily loaded members, so there is no need for Proxy.
    IModelFeature newObject = 
      new ModelFeature(key, geneModelNameValue, locusTairObjectIdValue, featureTypeValue, featureNumberValue, startValue, endValue, agiStartValue, agiEndValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a ModelFeature based on a result set that must contain
   * the ModelFeature primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a ModelFeature CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getModelFeaturePrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusGeneModelPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String featureTypeValue = rs.getString("featureType");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "featureType", featureTypeValue));
    java.lang.Integer featureNumberValue = rs.getInt("featureNumber");
    list.add(new com.poesys.db.col.IntegerColumnValue(prefix + "featureNumber", featureNumberValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ModelFeature");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ModelFeature");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a ModelFeature based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param featureNumber an integer that uniquely identifies the feature within the locus, gene model,
and feature type; also orders the feature within the feature type
   * @param featureType the kind of feature: intron or exon
   * @param geneModelName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a ModelFeature CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getModelFeaturePrimaryKey(java.lang.Integer featureNumber, java.lang.String featureType, java.lang.String geneModelName, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusGeneModelPrimaryKey(geneModelName, locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("featureType", featureType));
      list.add(new com.poesys.db.col.IntegerColumnValue("featureNumber", featureNumber));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.ModelFeature");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.ModelFeature");
    }
    return key;
  }

  /**
   * Retrieve the LocuslEst data from the result set's current row and create
   * a LocuslEst object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocuslEst instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocuslEst getLocuslEstData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument cloneEndTairObjectId gets the JDBC value with a function call.
    java.lang.Long cloneEndTairObjectIdValue = rs.getLong("cloneEndTairObjectId");
    // Constructor argument estName gets the JDBC value with a function call.
    java.lang.String estNameValue = rs.getString("estName");
    // Constructor argument icAccession gets the JDBC value with a function call.
    java.lang.String icAccessionValue = rs.getString("icAccession");
    // Constructor argument length gets the JDBC value with a function call.
    java.lang.Long lengthValue = rs.getLong("length");
    // Constructor argument start gets the JDBC value with a function call.
    java.lang.Long startValue = rs.getLong("startPosition");
    // Constructor argument end gets the JDBC value with a function call.
    java.lang.Long endValue = rs.getLong("endPosition");
    // Constructor argument cloneName gets the JDBC value with a function call.
    java.lang.String cloneNameValue = rs.getString("cloneName");
    // Constructor argument cloneTairObjectId gets the JDBC value with a function call.
    java.lang.Long cloneTairObjectIdValue = rs.getLong("cloneTairObjectId");
    // LocuslEst has no lazily loaded members, so there is no need for Proxy.
    ILocuslEst newObject = 
      new LocuslEst(key, locusTairObjectIdValue, cloneEndTairObjectIdValue, estNameValue, icAccessionValue, lengthValue, startValue, endValue, cloneNameValue, cloneTairObjectIdValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocuslEst based on a result set that must contain
   * the LocuslEst primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocuslEst CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocuslEstPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.Long cloneEndTairObjectIdValue = rs.getLong("cloneEndTairObjectId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "cloneEndTairObjectId", cloneEndTairObjectIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocuslEst");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocuslEst");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocuslEst based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param cloneEndTairObjectId the unique TAIR identifier for the EST clone end
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocuslEst CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocuslEstPrimaryKey(java.lang.Long cloneEndTairObjectId, java.lang.Long locusTairObjectId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.LongColumnValue("cloneEndTairObjectId", cloneEndTairObjectId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocuslEst");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocuslEst");
    }
    return key;
  }

  /**
   * Retrieve the LocusOtherName data from the result set's current row and create
   * a LocusOtherName object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusOtherName instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusOtherName getLocusOtherNameData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // LocusOtherName has no lazily loaded members, so there is no need for Proxy.
    ILocusOtherName newObject = 
      new LocusOtherName(key, locusTairObjectIdValue, nameValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusOtherName based on a result set that must contain
   * the LocusOtherName primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusOtherName CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusOtherNamePrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String nameValue = rs.getString("name");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "name", nameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusOtherName");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusOtherName");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusOtherName based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param name the alternative name for the parent locus
   * @return a LocusOtherName CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusOtherNamePrimaryKey(java.lang.Long locusTairObjectId, java.lang.String name)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusDetailPrimaryKey(locusTairObjectId);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("name", name));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusOtherName");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusOtherName");
    }
    return key;
  }

  /**
   * Retrieve the LocusGermplasm data from the result set's current row and create
   * a LocusGermplasm object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusGermplasm instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusGermplasm getLocusGermplasmData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument polymorphismName gets the JDBC value with a function call.
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    // Constructor argument germplasmName gets the JDBC value with a function call.
    java.lang.String germplasmNameValue = rs.getString("germplasmName");
    // Constructor argument germplasmTairObjectId gets the JDBC value with a function call.
    java.lang.Long germplasmTairObjectIdValue = rs.getLong("germplasmTairObjectId");
    // Constructor argument phenotype gets the JDBC value with a function call.
    java.lang.String phenotypeValue = rs.getString("phenotype");
    // LocusGermplasm has no lazily loaded members, so there is no need for Proxy.
    ILocusGermplasm newObject = 
      new LocusGermplasm(key, locusTairObjectIdValue, polymorphismNameValue, germplasmNameValue, germplasmTairObjectIdValue, phenotypeValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusGermplasm based on a result set that must contain
   * the LocusGermplasm primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusGermplasm CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGermplasmPrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusInducedPolymorphismPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String germplasmNameValue = rs.getString("germplasmName");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "germplasmName", germplasmNameValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGermplasm");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGermplasm");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusGermplasm based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param germplasmName the name of the germplasm that contains the induced polymorphism
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param polymorphismName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusGermplasm CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusGermplasmPrimaryKey(java.lang.String germplasmName, java.lang.Long locusTairObjectId, java.lang.String polymorphismName)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusInducedPolymorphismPrimaryKey(locusTairObjectId, polymorphismName);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("germplasmName", germplasmName));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusGermplasm");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusGermplasm");
    }
    return key;
  }

  /**
   * Retrieve the LocusNaturalVariationEcotype data from the result set's current row and create
   * a LocusNaturalVariationEcotype object.
   * 
   * @param key the primary key for the Locusdetail
   * @param rs the query result set
   * @return a LocusNaturalVariationEcotype instance based on the result set data
   * @throws SQLException when there is a problem getting data from the results
   * @throws InvalidParametersException when a required value is null
   */
  public static ILocusNaturalVariationEcotype getLocusNaturalVariationEcotypeData(IPrimaryKey key, ResultSet rs)
      throws SQLException, InvalidParametersException {
    // Constructor argument locusTairObjectId gets the JDBC value with a function call.
    java.lang.Long locusTairObjectIdValue = rs.getLong("locusTairObjectId");
    // Constructor argument polymorphismName gets the JDBC value with a function call.
    java.lang.String polymorphismNameValue = rs.getString("polymorphismName");
    // Constructor argument accession gets the JDBC value with a function call.
    java.lang.String accessionValue = rs.getString("accession");
    // Constructor argument name gets the JDBC value with a function call.
    java.lang.String nameValue = rs.getString("name");
    // Constructor argument taxonId gets the JDBC value with a function call.
    java.lang.Long taxonIdValue = rs.getLong("taxonId");
    // LocusNaturalVariationEcotype has no lazily loaded members, so there is no need for Proxy.
    ILocusNaturalVariationEcotype newObject = 
      new LocusNaturalVariationEcotype(key, locusTairObjectIdValue, polymorphismNameValue, accessionValue, nameValue, taxonIdValue);
    return newObject;
  }
  
  /**
   * <p>
   * Get a primary key for a LocusNaturalVariationEcotype based on a result set that must contain
   * the LocusNaturalVariationEcotype primary key columns. The method creates a primary key of
   * a type specified by the primary key stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param rs a JDBC result set with primary key columns
   * @param prefix an optional prefix string for derived column names in 
   *               associations
   * @return a LocusNaturalVariationEcotype CompositeKey primary key
   * @throws SQLException when there is a problem getting data from the result
   *             set
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusNaturalVariationEcotypePrimaryKey(ResultSet rs, String prefix)
      throws SQLException, InvalidParametersException {
    IPrimaryKey key = null;
    if (prefix == null) {
      prefix = "";
    }
    IPrimaryKey parentKey = getLocusNaturalVariationPrimaryKey(rs, "");
    java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
    java.lang.String accessionValue = rs.getString("accession");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "accession", accessionValue));
    java.lang.String nameValue = rs.getString("name");
    list.add(new com.poesys.db.col.StringColumnValue(prefix + "name", nameValue));
    java.lang.Long taxonIdValue = rs.getLong("taxonId");
    list.add(new com.poesys.db.col.LongColumnValue(prefix + "taxonId", taxonIdValue));
	IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusNaturalVariationEcotype");
    key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusNaturalVariationEcotype");
    return key;
  }

  /**
   * <p>
   * Get a primary key for a LocusNaturalVariationEcotype based on input key attributes. 
   * The method creates a primary key of a type specified by the primary key 
   * stereotype on the persistent class.
   * </p>
   * <p>
   * Stereotypes:
   * </p>
   * <ul>
   *     <li>CompositeKey</li>
   *     <li>Persistent</li>
   * </ul>
   * 
   * @param accession the accession identifier for this particular variant (second part of the primary
key); nulls in the original database translate into zero.
   * @param locusTairObjectId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param name the name of the variant ecotype or species variant; first part of the primary
key
   * @param polymorphismName composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @param taxonId composite super-key attribute that uniquely identifies child combined with child sub-key and any other parent super-keys
   * @return a LocusNaturalVariationEcotype CompositeKey primary key
   * @throws InvalidParametersException when there is a problem creating a key
   */
  public static IPrimaryKey getLocusNaturalVariationEcotypePrimaryKey(java.lang.String accession, java.lang.Long locusTairObjectId, java.lang.String name, java.lang.String polymorphismName, java.lang.Long taxonId)
      throws InvalidParametersException {
    IPrimaryKey key = null;
    IPrimaryKey parentKey = getLocusNaturalVariationPrimaryKey(locusTairObjectId, polymorphismName);

    // Check the parent key; if it is null, the return key should be null.
    if (parentKey != null) {
      java.util.ArrayList<com.poesys.db.col.AbstractColumnValue> list =
        new java.util.ArrayList<com.poesys.db.col.AbstractColumnValue>();
      list.add(new com.poesys.db.col.StringColumnValue("accession", accession));
      list.add(new com.poesys.db.col.StringColumnValue("name", name));
      list.add(new com.poesys.db.col.LongColumnValue("taxonId", taxonId));
	  IPrimaryKey subKey = com.poesys.db.pk.PrimaryKeyFactory.createNaturalKey(list, "org.tair.db.locusdetail.LocusNaturalVariationEcotype");
      key = com.poesys.db.pk.PrimaryKeyFactory.createCompositeKey(parentKey, subKey, "org.tair.db.locusdetail.LocusNaturalVariationEcotype");
    }
    return key;
  }

}