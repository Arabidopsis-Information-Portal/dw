/**
 * Copyright 2012 Carnegie Institution for Science. All rights reserved.
 */
// Generated by AndroMDA Poesys/DB cartridge: DO NOT EDIT DIRECTLY.
// Template: AbstractDbDto.vsl

package org.tair.db.community;


import com.poesys.db.pk.IPrimaryKey;

/**
 * <p>
 * A data-access layer data-transfer object for the Person. This class
 * is an abstract class that contains AndroMDA generated code; change nothing
 * in this class. Instead, override any methods in the concrete subclass
 * generated in the same package. AndroMDA will overwrite this class each time
 * you run it but will never overwrite the concrete subclass.
 * </p>
 * <p>
 * a person who is a member of the community
 * </p>
 * <p>
 * Stereotypes:
 * </p>
 * <ul>
 *     <li>Persistent</li>
 * </ul>
 * <p>
 * Class is read/write: false
 * </p>
 *
 * @author Poesys/DB Cartridge
 */
public abstract class AbstractPerson extends org.tair.db.community.Community implements IPerson {
  /** Default serial version UID for the Serializable DTO */
  private static final long serialVersionUID = 1L;
  
  // Setter strategy nested classes for multiple-object associations

   
   
  /**
   * Create an empty Person for use in building a new object. The 
   * concrete subclass must call this constructor.
   */
  public AbstractPerson() {
    super();
    // Setter arrays
    querySetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    insertSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    preSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    postSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    readObjectSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    
    // Add the many-to-many collection setters for the organization property.
    
    // Add the many-to-many collection setters for the affiliation property.
  }

  /**
   * Create a Person. The concrete subclass must call this constructor.
   *
   * @param key the primary key of the Person
   * @param communityId primary key attribute
   * @param communityType the kind of community member this is: person or organization
   * @param email the email address of the community member
   * @param memberStatus the current status of the community member: new, active, inactive.
A new member is one who has registered but not been activated.
An active member has been activated.
An inactive member has been inactivated.
   * @param countryId foreign key used by setter to query associated object
   * @param userName the person's login user name
   * @param firstName the first name of the person
   * @param middleName the middle name of the person
   * @param lastName the last name of the person
   * @param suffix an optional suffix for the person's name, such as Jr., III, and so on
   * @param researchInterest a text description of the person's research interests
   */
  public AbstractPerson(IPrimaryKey key, java.math.BigInteger communityId, java.lang.String communityType, java.lang.String email, java.lang.String memberStatus, java.math.BigInteger countryId, java.lang.String userName, java.lang.String firstName, java.lang.String middleName, java.lang.String lastName, java.lang.String suffix, java.lang.String researchInterest) {
    super(key, communityId, communityType, email, memberStatus, countryId);

    this.userName = userName;

    if (userName == null) {
      throw new com.poesys.db.InvalidParametersException("userName is required for " + key.getValueList());
    }
    
    this.firstName = firstName;

    this.middleName = middleName;

    this.lastName = lastName;

    if (lastName == null) {
      throw new com.poesys.db.InvalidParametersException("lastName is required for " + key.getValueList());
    }
    
    this.suffix = suffix;

    this.researchInterest = researchInterest;

    // Setter arrays
    querySetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    insertQuerySetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    insertSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    preSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    postSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    readObjectSetters = new java.util.concurrent.CopyOnWriteArrayList<com.poesys.db.dto.ISet>();
    
    // Add the many-to-many collection setters for the organization property.
    
    // Add the many-to-many collection setters for the affiliation property.
  }


  /**
   * Nested property userName
   *
   * <p>
   * the person's login user name
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String userName;
  

  public java.lang.String getUserName() {
    return userName;
  }

  /**
   * Clear the userName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearUserName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property firstName
   *
   * <p>
   * the first name of the person
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String firstName;
  

  public java.lang.String getFirstName() {
    return firstName;
  }

  /**
   * Clear the firstName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearFirstName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property middleName
   *
   * <p>
   * the middle name of the person
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String middleName;
  

  public java.lang.String getMiddleName() {
    return middleName;
  }

  /**
   * Clear the middleName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearMiddleName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property lastName
   *
   * <p>
   * the last name of the person
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String lastName;
  

  public java.lang.String getLastName() {
    return lastName;
  }

  /**
   * Clear the lastName data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearLastName() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property suffix
   *
   * <p>
   * an optional suffix for the person's name, such as Jr., III, and so on
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String suffix;
  

  public java.lang.String getSuffix() {
    return suffix;
  }

  /**
   * Clear the suffix data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearSuffix() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property researchInterest
   *
   * <p>
   * a text description of the person's research interests
   * </p>
   *
   * Added by AddLocalAttributeProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: false
   */
  private java.lang.String researchInterest;
  

  public java.lang.String getResearchInterest() {
    return researchInterest;
  }

  /**
   * Clear the researchInterest data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearResearchInterest() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * Nested property organization
   *
   * <p>
   * the set of organizations to which a person belongs
   * </p>
   *
   * Added by TransformToProperty + AddToManyAssociationCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: false
   * Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.community.IOrganization> organization;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> organizationKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.community.IOrganization> getOrganization() throws java.sql.SQLException {
    return organization;
  }

  /**
   * Clear the organization data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearOrganization() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  public void setOrganization(java.util.Collection<org.tair.db.community.IOrganization> organization) {
    this.organization = organization;
    // Add the primary keys of the new collection to the serialized key list.
    organizationKeys.clear();
    if (organization != null) {
      for (com.poesys.db.dto.IDbDto object : organization) {
        organizationKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  /**
   * Nested property affiliation
   *
   * <p>
   * Collection of association class objects (not the associated objects)
   * </p>
   *
   * Added by AddAssociationClassCollectionProperties
   * Class is read/write: false
   * Class is immutable: false
   * Property is read/write: true
   * Property is lazy: true
   */
  // Doesn't serialize; package access allows proxy to set on readObject()
  transient java.util.Collection<org.tair.db.community.IAffiliation> affiliation;
  // Ordered list of keys of the objects in the $property.uniquename list
  java.util.List<com.poesys.db.pk.IPrimaryKey> affiliationKeys = 
    new java.util.ArrayList<com.poesys.db.pk.IPrimaryKey>();
  

  public java.util.Collection<org.tair.db.community.IAffiliation> getAffiliation() throws java.sql.SQLException {
    return affiliation;
  }

  /**
   * Clear the affiliation data member; override in proxy if lazily loaded,
   * otherwise this method does nothing.
   */
  public void clearAffiliation() {
    // Override in proxy if lazily loaded; otherwise does nothing
  }

  /**
   * <p>
   * Set the affiliation.
   * </p>
   * <ul>
   * <li>Read/Write DTO: false</li>
   * <li>Immutable DTO: false</li>
   * <li>Read/Write property: true</li>
   * <li>Immutable property: false</li>
   * <li>Lazy property: true (if true, proxy calls this method)</li>
   * </ul>
   * <p>
   * Collection of association class objects (not the associated objects)
   * </p>
   *
   * @param affiliation the value with which to set the property
   * @throws com.poesys.db.InvalidParametersException when the input affiliation is null
   */
  public void setAffiliation(java.util.Collection<org.tair.db.community.IAffiliation> affiliation)
      throws com.poesys.db.InvalidParametersException {
    if (affiliation == null) {
      throw new com.poesys.db.InvalidParametersException("affiliation is required");
    }
    
    this.affiliation = affiliation;
    // Add the primary keys of the new collection to the serialized key list.
    affiliationKeys.clear();
    if (affiliation != null) {
      for (com.poesys.db.dto.IDbDto object : affiliation) {
        affiliationKeys.add(object.getPrimaryKey());
      }
    }
    setChanged();
  }

  @Override
  public void update(com.poesys.db.dto.ISubject subject,
                     com.poesys.db.dao.DataEvent event)
      throws com.poesys.db.dto.DtoStatusException {

    // Clean up affiliation.
    if (subject != null && subject instanceof org.tair.db.community.IAffiliation && 
        event == com.poesys.db.dao.DataEvent.DELETE &&
        affiliation != null) {
      // Delete to-many affiliation child from collection
      affiliation.remove(subject);
      subject.detach(this, com.poesys.db.dao.DataEvent.MARKED_DELETED);
      subject.detach(this, com.poesys.db.dao.DataEvent.DELETE);
    }

    // Cascade delete to affiliation.
    if (event == com.poesys.db.dao.DataEvent.MARKED_DELETED &&
        affiliation != null) {
      // Mark affiliation association object cascade-deleted.
      outer: for (org.tair.db.community.IAffiliation value : affiliation) {
        com.poesys.db.pk.AssociationPrimaryKey keys = 
          (com.poesys.db.pk.AssociationPrimaryKey) value.getPrimaryKey();
        for (com.poesys.db.pk.IPrimaryKey key : keys.getKeyListCopy()) {
          if (key.equals(subject.getPrimaryKey())) {
            value.cascadeDelete();
            break outer;
          }
        }
      }
    }
  }
}